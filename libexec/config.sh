#!/bin/bash

usage()
{
    echo 'Usage: config.sh [-nowait]'
    echo "The -nowait option skips waiting for peers in multi-server config"
    exit 1
} >&2


NOWAIT=false
if [ "$1" = "-nowait" ]; then
    NOWAIT=true
    shift
fi

if [ $# != 0 ]; then
    usage
fi

echo
echo "Starting vault configuration at `date`"

LIBEXEC=/usr/libexec/htvault-config
VARLIB=/var/lib/htvault-config
cd $VARLIB

if $LIBEXEC/parseconfig.py > config.json.new; then
    mv config.json.new config.json
    if $LIBEXEC/jsontobash.py <config.json >config.bash.new; then
        mv config.bash.new config.bash
    else
        echo "Failure converting config.json to config.bash" >&2
        exit 1
    fi
else
    echo "Failure converting /etc/htvault-config/config.d/*.yaml to config.json" >&2
    exit 1
fi

. config.bash

ISMASTER=true
if [ -n "$_cluster_master" ] && [ "$_cluster_master" != "$_cluster_name" ]; then
    ISMASTER=false
fi
SERVICENAME="${_cluster_master:-${_cluster_name:-`uname -n`}}"
export VAULT_ADDR=http://127.0.0.1:8202

if [ -n "$_cluster_master" ]; then
    vault operator raft join -format=json $VAULT_ADDR | jq -r keys[0]
fi

if [ ! -f vaultseal.txt ] && $ISMASTER; then
    echo "Initializing database"
    if ! vault operator init -key-shares=1 -key-threshold=1 -format=json >keys.json; then
        echo "Failed to initialize vault DB" >&2
        rm -f keys.json
        exit 2
    fi
    jq -r ".unseal_keys_b64[0]" keys.json >vaultseal.txt
    jq -r ".root_token" keys.json >~/.vault-token
    chmod 600 vaultseal.txt ~/.vault-token
    if [ ! -s vaultseal.txt ] || [ ! -s ~/.vault-token ]; then
        echo "Failed to get unseal key or root vault token" >&2
        exit 2
    fi
fi

if vault status >/dev/null; then
    echo "vault is unsealed"
else
    echo "vault status failed, attempting to unseal"
    # Try multiple times because it can take a while to initialize a new
    #   raft storage from peers.
    TRY=0
    MAX=20
    while [ "$TRY" -lt "$MAX" ]; do
	vault operator unseal `cat vaultseal.txt`
	if vault status >/dev/null; then
	    break
	fi
	let TRY+=1
	echo "Unseal try $TRY failed"
	sleep 1
    done
    if [ "$TRY" -eq "$MAX" ]; then
	echo "Giving up"
	exit 1
    fi
fi

if ! $NOWAIT && [ "`vault status -format=json|jq -r .storage_type`" = "raft" ]; then
    TRY=0
    MAX=20
    while [ "$TRY" -lt "$MAX" ]; do
	if vault operator raft list-peers; then
	    break
	fi
	let TRY+=1
	echo "Waiting for peers, try $TRY"
	sleep 1
    done
    if [ "$TRY" -eq "$MAX" ]; then
	echo "Giving up"
	exit 1
    fi
fi

if ! $ISMASTER; then
    echo "Completed vault configuration at `date`"
    exit 0
fi

ENABLEDMODS="`
    (vault auth list -format=json|jq keys
     vault secrets list -format=json|jq keys)| \
      egrep "(kerberos|oidc|oauth)"| \
       sed 's/"//g;s-/,--;s-[^ /]*/--'`"

# remove newlines
ENABLEDMODS="`echo $ENABLEDMODS`"

FORCEMODS="$@"

modenabled()
{
    case " $ENABLEDMODS " in
	*" $1 "*)
            return
            ;;
    esac
    return 1
}

loadplugin()
{
    typeset PLUGIN="vault-plugin-$1.sh"
    typeset SHA="`sha256sum $LIBEXEC/plugins/$PLUGIN|awk '{print $1}'`"
    typeset CATPATH="sys/plugins/catalog/$2"
    if [ "`vault read $CATPATH -format=json 2>/dev/null|jq -r .data.sha256`" != "$SHA" ]; then
	echo "Defining plugin $1"
	vault write $CATPATH sha256=$SHA command=$PLUGIN
    fi
}

POLICIES="oidc"
ISFIRST=true
for KERBSERVICE in $_kerberos; do
    if $ISFIRST; then
        ISFIRST=false
        KERBSUFFIX=""
    else
        KERBSUFFIX="-$KERBSERVICE"
    fi
    POLICIES="$POLICIES kerberos$KERBSERVICE"
    echo "Configuring kerberos$KERBSUFFIX"
    vault auth disable kerberos$KERBSUFFIX
    vault auth enable -path=kerberos$KERBSUFFIX \
	-passthrough-request-headers=Authorization \
	-allowed-response-headers=www-authenticate kerberos
    base64 /etc/krb5$KERBSUFFIX.keytab >krb5.keytab.base64
    vault write auth/kerberos$KERBSUFFIX/config \
	keytab=@$VARLIB/krb5.keytab.base64 \
	service_account="host/$SERVICENAME"
    rm -f krb5.keytab.base64

    for VAR in ldapattr ldapdn ldapurl; do
        eval $VAR="\$_kerberos_${KERBSERVICE}_$VAR"
    done

    vault write auth/kerberos$KERBSUFFIX/config/ldap \
	url="$ldapurl" \
	userdn="$ldapdn" \
	userattr="$ldapattr" \
	token_policies="kerberos${KERBSERVICE}policy,tokencreatepolicy"
done

loadplugin secrets-oauthapp secret/oauthapp
loadplugin auth-jwt auth/oidc

for POLICY in $POLICIES; do
    rm -f ${POLICY}policy.hcl
    echo "/* Do not edit this file, generated from ${POLICY}policy.template */" >${POLICY}policy.hcl
done

for TYPEMOD in auth/oidc secrets/oauthapp; do
    TYPE=${TYPEMOD%%/*}
    MOD=${TYPEMOD##*/}
    if modenabled $MOD; then
        # this can happen during the first initialization
        vault $TYPE disable $MOD
    fi
done

for ISSUER in $_issuers; do 
    VPATH=oidc-$ISSUER
    REDIRECT_URIS="https://$SERVICENAME:8200/v1/auth/$VPATH/oidc/callback"

    for VAR in clientid secret url roles callbackmode credclaim; do
        eval $VAR="\$_issuers_${ISSUER}_$VAR"
    done

    echo "Configuring $VPATH"
    vault auth disable $VPATH
    vault auth enable -path=$VPATH oidc
    VPATH=auth/$VPATH
    vault write $VPATH/config \
        oidc_client_id="$clientid" \
        oidc_client_secret="$secret" \
        default_role="default" \
        oidc_discovery_url="$url" 

    for ROLE in $roles; do
        eval scopes="\$_issuers_${ISSUER}_roles_${ROLE}_scopes"

        echo "Configuring $VPATH role $ROLE with scopes $scopes"
        echo -n '{"claim_mappings": {"'$OIDC_USERCLAIM'" : "credkey"}, "oauth2_metadata": ["refresh_token"]}'| \
          vault write $VPATH/role/$ROLE - \
            role_type="oidc" \
            user_claim="$credclaim" \
            groups_claim="" \
            oidc_scopes="$scopes" \
            policies=default,oidcpolicy,tokencreatepolicy \
            callback_mode="${callbackmode:-device}" \
            poll_interval=3 \
            allowed_redirect_uris="$REDIRECT_URIS" \
            verbose_oidc_logging=true
    done

    VPATH=secret/oauth-$ISSUER
    echo "Configuring $VPATH"
    if ! modenabled oauth-$ISSUER; then
        # don't ever disable this because that causes secrets to be lost
	vault secrets enable -path=$VPATH oauthapp
    fi

    vault write $VPATH/config \
        provider="oidc" \
        provider_options="issuer_url=$url" \
        client_id="$clientid" \
        client_secret="$secret" \
        tune_refresh_check_interval_seconds=0

    ISFIRST=true
    for POLICY in $POLICIES; do
	POLICYISSUER="$POLICY"
	TEMPLATEPOLICY=$POLICY
	if [ "$POLICY" = oidc ]; then
	    POLICYISSUER="$POLICY-$ISSUER"
	elif [[ "$POLICY" =~ ^kerberos ]]; then
            KERBSERVICE=${POLICY/kerberos/}
            if $ISFIRST; then
                ISFIRST=false
                KERBSUFFIX=""
            else
                KERBSUFFIX="-$KERBSERVICE"
            fi
            eval policydomain="\$_kerberos_${KERBSERVICE}_policydomain"
	    TEMPLATEPOLICY=kerberos
	    POLICYISSUER=kerberos$KERBSUFFIX
	fi
	ACCESSOR="`vault read sys/auth -format=json|jq -r '.data."'$POLICYISSUER'/".accessor'`"
	sed -e "s,<vpath>,$VPATH," -e "s/<${TEMPLATEPOLICY}>/$ACCESSOR/" -e "s/@<domain>/$policydomain/" $LIBEXEC/${TEMPLATEPOLICY}policy.template >>${POLICY}policy.hcl
    done
done

# global policies
for POLICY in tokencreate; do
    cat $LIBEXEC/${POLICY}policy.template >${POLICY}policy.hcl
    vault policy write ${POLICY}policy ${POLICY}policy.hcl
done

echo "Loading policies"
for POLICY in oidc kerberos kerberos2 tokencreate; do
    if [ -f ${POLICY}policy.hcl ]; then
	chmod a-w ${POLICY}policy.hcl
	vault policy write ${POLICY}policy ${POLICY}policy.hcl
    fi
done

echo "Completed vault configuration at `date`"
