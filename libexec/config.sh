#!/bin/bash

usage()
{
    echo 'Usage: config.sh [-nowait]'
    echo "The -nowait option skips waiting for peers in multi-server config"
    exit 1
} >&2


NOWAIT=false
if [ "$1" = "-nowait" ]; then
    NOWAIT=true
    shift
fi

if [ $# != 0 ]; then
    usage
fi

echo
echo "Starting vault configuration at `date`"

PARAMS=/etc/htvault-config/config.d/parameters.sh
if [ ! -f $PARAMS ]; then
    echo "$PARAMS missing" >&2
    exit 1
fi
. $PARAMS

ISMASTER=true
if [ -n "$CLUSTERFQDN" ] && [ "$CLUSTERMASTER" != "$MYFQDN" ]; then
    ISMASTER=false
fi
SERVICENAME="${CLUSTERFQDN:-$MYFQDN}"
export VAULT_ADDR=http://127.0.0.1:8200
LIBEXEC=/usr/libexec/htvault-config
VARLIB=/var/lib/htvault-config
cd $VARLIB

if [ -n "$CLUSTERFQDN" ]; then
    vault operator raft join -format=json $VAULT_ADDR | jq -r keys[0]
fi

if [ ! -f vaultseal.txt ] && $ISMASTER; then
    # create a new DB
    vault operator init -key-shares=1 -key-threshold=1 -format=json >keys.json
    jq -r ".unseal_keys_b64[0]" keys.json >vaultseal.txt
    jq -r ".root_token" keys.json >~/.vault-token
    chmod 600 vaultseal.txt ~/.vault-token
    rm -f keys.json
fi

if vault status >/dev/null; then
    echo "vault is unsealed"
else
    echo "vault status failed, attempting to unseal"
    # Try multiple times because it can take a while to initialize a new
    #   raft storage from peers.
    TRY=0
    MAX=20
    while [ "$TRY" -lt "$MAX" ]; do
	vault operator unseal `cat vaultseal.txt`
	if vault status >/dev/null; then
	    break
	fi
	let TRY+=1
	echo "Unseal try $TRY failed"
	sleep 1
    done
    if [ "$TRY" -eq "$MAX" ]; then
	echo "Giving up"
	exit 1
    fi
fi

if ! $NOWAIT && [ "`vault status -format=json|jq -r .storage_type`" = "raft" ]; then
    TRY=0
    MAX=20
    while [ "$TRY" -lt "$MAX" ]; do
	if vault operator raft list-peers; then
	    break
	fi
	let TRY+=1
	echo "Waiting for peers, try $TRY"
	sleep 1
    done
    if [ "$TRY" -eq "$MAX" ]; then
	echo "Giving up"
	exit 1
    fi
fi

if ! $ISMASTER; then
    echo "Completed vault configuration at `date`"
    exit 0
fi

ENABLEDMODS="`
    (vault auth list -format=json|jq keys
     vault secrets list -format=json|jq keys)| \
      egrep "(kerberos|oidc|oauth)"| \
       sed 's/"//g;s-/,--;s-[^ /]*/--'`"

# remove newlines
ENABLEDMODS="`echo $ENABLEDMODS`"

FORCEMODS="$@"

modenabled()
{
    case " $ENABLEDMODS " in
	*" $1 "*)
            return
            ;;
    esac
    return 1
}

loadplugin()
{
    typeset PLUGIN="vault-plugin-$1.sh"
    typeset SHA="`sha256sum $LIBEXEC/plugins/$PLUGIN|awk '{print $1}'`"
    typeset CATPATH="sys/plugins/catalog/$2"
    if [ "`vault read $CATPATH -format=json 2>/dev/null|jq -r .data.sha256`" != "$SHA" ]; then
	echo "Defining plugin $1"
	vault write $CATPATH sha256=$SHA command=$PLUGIN
    fi
}

if [ -n "$LDAPURL" ]; then
    echo "Configuring kerberos"
    #run this to enable kerberos debugging (if kerberos plugin is installed)
    #loadplugin auth-kerberos auth/kerberos

    vault auth disable kerberos
    vault auth enable \
	-passthrough-request-headers=Authorization \
	-allowed-response-headers=www-authenticate kerberos
    base64 /etc/krb5.keytab >krb5.keytab.base64
    vault write auth/kerberos/config \
	keytab=@$VARLIB/krb5.keytab.base64 \
	service_account="host/$SERVICENAME"
    rm -f krb5.keytab.base64

    vault write auth/kerberos/config/ldap \
	url="$LDAPURL" \
	userdn="$LDAPDN" \
	userattr="$LDAPATTR" \
	token_policies="kerberospolicy,tokencreatepolicy"
fi
if [ -n "$KERB2NAME" ]; then
    echo "Configuring kerberos-$KERB2NAME"
    vault auth disable kerberos-$KERB2NAME
    vault auth enable -path=kerberos-$KERB2NAME \
	-passthrough-request-headers=Authorization \
	-allowed-response-headers=www-authenticate kerberos
    base64 /etc/krb5-$KERB2NAME.keytab >krb5.keytab.base64
    vault write auth/kerberos-$KERB2NAME/config \
	keytab=@$VARLIB/krb5.keytab.base64 \
	service_account="host/$SERVICENAME"
    rm -f krb5.keytab.base64

    vault write auth/kerberos-$KERB2NAME/config/ldap \
	url="$LDAPURL2" \
	userdn="$LDAPDN2" \
	userattr="$LDAPATTR2" \
	token_policies="kerberos2policy,tokencreatepolicy"
fi


loadplugin secrets-oauthapp secret/oauthapp
loadplugin auth-jwt auth/oidc

for POLICY in oidc kerberos kerberos2; do
    rm -f ${POLICY}policy.hcl
    echo "/* Do not edit this file, generated from ${POLICY}policy.template */" >${POLICY}policy.hcl
done

for TYPEMOD in auth/oidc secrets/oauthapp; do
    TYPE=${TYPEMOD%%/*}
    MOD=${TYPEMOD##*/}
    if modenabled $MOD; then
        # this can happen during the first initialization
        vault $TYPE disable $MOD
    fi
done

for ISSUER in $ISSUERS; do 
    VPATH=oidc-$ISSUER
    REDIRECT_URIS="https://$SERVICENAME:8200/v1/auth/$VPATH/oidc/callback"

    for VAR in OIDC_CLIENT_ID OIDC_CLIENT_SECRET OIDC_SERVER_URL OIDC_SCOPES OIDC_CALLBACKMODE OIDC_USERCLAIM OIDC_GROUPSCLAIM; do
        IVAR="${ISSUER}_$VAR"
        # this gives a way to copy any variable type including arrays
        eval unset $VAR 2>/dev/null
        if typeset temp=$(eval declare -p $IVAR 2>/dev/null); then
            eval ${temp/$IVAR=/$VAR=}
        fi
    done

    echo "Configuring $VPATH"
    vault auth disable $VPATH
    vault auth enable -path=$VPATH oidc
    VPATH=auth/$VPATH
    vault write $VPATH/config \
        oidc_client_id="$OIDC_CLIENT_ID" \
        oidc_client_secret="$OIDC_CLIENT_SECRET" \
        default_role="default" \
        oidc_discovery_url="$OIDC_SERVER_URL" 

    for key in ${!OIDC_SCOPES[@]}; do
        if [ "$key" = "0" ]; then
            # this is the key you get if OIDC_SCOPES is not an array
            role="default"
        else
            role=$key
        fi
        echo "Configuring $VPATH role $role with scopes ${OIDC_SCOPES[$role]}"
        echo -n '{"claim_mappings": {"'$OIDC_USERCLAIM'" : "credkey"}, "oauth2_metadata": ["refresh_token"]}'| \
          vault write $VPATH/role/$role - \
            role_type="oidc" \
            user_claim="$OIDC_USERCLAIM" \
            groups_claim="$OIDC_GROUPSCLAIM" \
            oidc_scopes="${OIDC_SCOPES[$key]}" \
            policies=default,oidcpolicy,tokencreatepolicy \
            callback_mode=$OIDC_CALLBACKMODE \
            poll_interval=3 \
            allowed_redirect_uris="$REDIRECT_URIS" \
            verbose_oidc_logging=true
    done

    VPATH=secret/oauth-$ISSUER
    echo "Configuring $VPATH"
    if ! modenabled oauth-$ISSUER; then
        # don't ever disable this because that causes secrets to be lost
	vault secrets enable -path=$VPATH oauthapp
    fi

    vault write $VPATH/config \
        provider="oidc" \
        provider_options="issuer_url=$OIDC_SERVER_URL" \
        client_id="$OIDC_CLIENT_ID" \
        client_secret="$OIDC_CLIENT_SECRET"

    for POLICY in oidc kerberos kerberos2; do
	POLICYISSUER="$POLICY"
	DOMAIN=$KERBPOLICYDOMAIN
	TEMPLATEPOLICY=$POLICY
	if [ "$POLICY" = oidc ]; then
	    POLICYISSUER="$POLICY-$ISSUER"
	elif [ "$POLICY" = kerberos2 ]; then
	    if [ -z "$KERB2NAME" ]; then
		rm -f ${POLICY}policy.hcl
		continue
	    fi
	    DOMAIN=$KERBPOLICYDOMAIN2
	    TEMPLATEPOLICY=kerberos
	    POLICYISSUER=kerberos-$KERB2NAME
	fi
	ACCESSOR="`vault read sys/auth -format=json|jq -r '.data."'$POLICYISSUER'/".accessor'`"
	sed -e "s,<vpath>,$VPATH," -e "s/<${TEMPLATEPOLICY}>/$ACCESSOR/" -e "s/@<domain>/$DOMAIN/" $LIBEXEC/${TEMPLATEPOLICY}policy.template >>${POLICY}policy.hcl
    done
done

# global policies
for POLICY in tokencreate; do
    cat $LIBEXEC/${POLICY}policy.template >${POLICY}policy.hcl
    vault policy write ${POLICY}policy ${POLICY}policy.hcl
done

echo "Loading policies"
for POLICY in oidc kerberos kerberos2 tokencreate; do
    if [ -f ${POLICY}policy.hcl ]; then
	chmod a-w ${POLICY}policy.hcl
	vault policy write ${POLICY}policy ${POLICY}policy.hcl
    fi
done

echo "Completed vault configuration at `date`"
