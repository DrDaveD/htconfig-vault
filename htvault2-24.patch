diff --git a/README.md b/README.md
index e0eae6d..897935c 100644
--- a/README.md
+++ b/README.md
@@ -163,9 +163,17 @@ Retrieve a current access token for the given credential. Reuses previous token
 if it is not yet expired or close to it. Otherwise, requests a new credential
 using the `refresh_token` grant type if possible.
 
+If scopes or audience are requested, the current access token will be
+exchanged for another access token with more limited scopes or audience,
+and the more limited token returned.
+The more limited token is not saved for reuse; the less limited one is
+saved as usual.
+
 | Name | Description | Type | Default | Required |
 |------|-------------|------|---------|----------|
-| `minimum_seconds` | Minimum seconds before access token expires | Integer | * | No |
+| `minimum_seconds` | Minimum seconds before access token expires. | Integer | * | No |
+| `scopes` | A list of explicit scopes to request. | List of String | None | No |
+| `audience` | An explicit audience to request. | String | None | No |
 
 \* Defaults to underlying library default, which is 10 seconds unless
   the token expiration time is set to zero.
diff --git a/pkg/backend/path_creds.go b/pkg/backend/path_creds.go
index f1db615..1b6411d 100644
--- a/pkg/backend/path_creds.go
+++ b/pkg/backend/path_creds.go
@@ -47,6 +47,35 @@ func (b *backend) credsReadOperation(ctx context.Context, req *logical.Request,
 		return logical.ErrorResponse("token expired"), nil
 	}
 
+	scopes := data.Get("scopes").([]string)
+	audiences := data.Get("audience").([]string)
+	if len(scopes) > 0 || len(audiences) > 0 {
+		// Do an RFC8693 token exchange to limit the access token
+		options := map[string]string{
+			"grant_type":         "urn:ietf:params:oauth:grant-type:token-exchange",
+			"subject_token":      tok.AccessToken,
+			"subject_token_type": "urn:ietf:params:oauth:token-type:access_token",
+		}
+		if len(scopes) > 0 {
+			options["scope"] = strings.Join(scopes, " ")
+		}
+		if len(audiences) > 0 {
+			options["audience"] = audiences[0]
+		}
+
+		c, err := b.getCache(ctx, req.Storage)
+		if err != nil {
+			return nil, err
+		} else if c == nil {
+			return logical.ErrorResponse("not configured"), nil
+		}
+		ops := c.Provider.Private(c.Config.ClientID, c.Config.ClientSecret)
+		tok, err = ops.AuthCodeExchange(ctx, "", provider.WithURLParams(options))
+		if err != nil {
+			return nil, err
+		}
+	}
+
 	rd := map[string]interface{}{
 		"access_token": tok.AccessToken,
 		"type":         tok.Type(),
@@ -154,6 +183,14 @@ var credsFields = map[string]*framework.FieldSchema{
 		Description: "Specifies the name of the credential.",
 	},
 	// fields for read operation
+	"scopes": {
+		Type:        framework.TypeCommaStringSlice,
+		Description: "The subset of scopes to request for access token, default same as refresh token.",
+	},
+	"audience": {
+		Type:        framework.TypeCommaStringSlice,
+		Description: "An audience to request for access token, default same as refresh token.",
+	},
 	"minimum_seconds": {
 		Type:        framework.TypeInt,
 		Description: "Minimum remaining seconds to allow when reusing access token.",
diff --git a/pkg/backend/path_creds_test.go b/pkg/backend/path_creds_test.go
index 9fe1054..ae877da 100644
--- a/pkg/backend/path_creds_test.go
+++ b/pkg/backend/path_creds_test.go
@@ -3,6 +3,7 @@ package backend
 import (
 	"context"
 	"fmt"
+	"net/url"
 	"testing"
 	"time"
 
@@ -294,3 +295,113 @@ func TestRefreshFailureReturnsNotConfigured(t *testing.T) {
 	require.NotNil(t, resp)
 	require.EqualError(t, resp.Error(), "token expired")
 }
+
+func TestScopesAndAudienceRequests(t *testing.T) {
+	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
+	defer cancel()
+
+	client := testutil.MockClient{
+		ID:     "hij",
+		Secret: "def",
+	}
+
+	storage := &logical.InmemStorage{}
+
+	b := New(Options{ProviderRegistry: provider.GlobalRegistry})
+	require.NoError(t, b.Setup(ctx, &logical.BackendConfig{}))
+
+	tp := testutil.NewMockTokenProvider()
+	defer tp.Close()
+
+	// Write configuration.
+	req := &logical.Request{
+		Operation: logical.UpdateOperation,
+		Path:      configPath,
+		Storage:   storage,
+		Data: map[string]interface{}{
+			"client_id":     client.ID,
+			"client_secret": client.Secret,
+			"provider":      "custom",
+			"provider_options": map[string]string{
+				"auth_code_url": "not-used",
+				"token_url":     tp.GetServerURL() + "/token",
+			},
+		},
+	}
+
+	resp, err := b.HandleRequest(ctx, req)
+	require.NoError(t, err)
+	require.False(t, resp != nil && resp.IsError(), "response has error: %+v", resp.Error())
+	require.Nil(t, resp)
+
+	// Write a valid credential.
+	req = &logical.Request{
+		Operation: logical.UpdateOperation,
+		Path:      credsPathPrefix + `test`,
+		Storage:   storage,
+		Data: map[string]interface{}{
+			"refresh_token": "test",
+		},
+	}
+
+	resp, err = b.HandleRequest(ctx, req)
+	require.NoError(t, err)
+	require.False(t, resp != nil && resp.IsError(), "response has error: %+v", resp.Error())
+	require.Nil(t, resp)
+
+	req = &logical.Request{
+		Operation: logical.ReadOperation,
+		Path:      credsPathPrefix + `test`,
+		Storage:   storage,
+	}
+
+	resp, err = b.HandleRequest(ctx, req)
+	require.NoError(t, err)
+	require.NotNil(t, resp)
+	require.False(t, resp.IsError(), "response has error: %+v", resp.Error())
+	require.NotNil(t, resp.Data["access_token"])
+	v, err := url.ParseQuery(resp.Data["access_token"].(string))
+	require.NoError(t, err)
+	default_scopes := v["scopes"]
+	require.NotNil(t, default_scopes)
+	default_audience := v["audience"]
+	require.NotNil(t, default_audience)
+
+	req = &logical.Request{
+		Operation: logical.ReadOperation,
+		Path:      credsPathPrefix + `test`,
+		Storage:   storage,
+		Data: map[string]interface{}{
+			"scopes": "scopea,scopec",
+		},
+	}
+
+	resp, err = b.HandleRequest(ctx, req)
+	require.NoError(t, err)
+	require.NotNil(t, resp)
+	require.False(t, resp.IsError(), "response has error: %+v", resp.Error())
+	require.NotNil(t, resp.Data["access_token"])
+	v, err = url.ParseQuery(resp.Data["access_token"].(string))
+	require.NoError(t, err)
+	require.Equal(t, []string{"scopea scopec"}, v["scopes"])
+	require.Equal(t, default_audience, v["audience"])
+
+	req = &logical.Request{
+		Operation: logical.ReadOperation,
+		Path:      credsPathPrefix + `test`,
+		Storage:   storage,
+		Data: map[string]interface{}{
+			"audience": "specific",
+		},
+	}
+
+	resp, err = b.HandleRequest(ctx, req)
+	require.NoError(t, err)
+	require.NotNil(t, resp)
+	require.False(t, resp.IsError(), "response has error: %+v", resp.Error())
+	require.NotNil(t, resp.Data["access_token"])
+	v, err = url.ParseQuery(resp.Data["access_token"].(string))
+	require.NoError(t, err)
+	require.Equal(t, default_scopes, v["scopes"])
+	require.Equal(t, []string{"specific"}, v["audience"])
+}
diff --git a/pkg/backend/token_authcode.go b/pkg/backend/token_authcode.go
index a404c36..4feab67 100644
--- a/pkg/backend/token_authcode.go
+++ b/pkg/backend/token_authcode.go
@@ -50,6 +50,8 @@ func (b *backend) refreshAuthCodeToken(ctx context.Context, storage logical.Stor
 		return tok, nil
 	}
 
+	tok.AccessToken = ""
+
 	c, err := b.getCache(ctx, storage)
 	if err != nil {
 		return nil, err
diff --git a/pkg/provider/oidc.go b/pkg/provider/oidc.go
index 2173411..37a02d5 100644
--- a/pkg/provider/oidc.go
+++ b/pkg/provider/oidc.go
@@ -116,8 +116,12 @@ func (oo *oidcOperations) AuthCodeExchange(ctx context.Context, code string, opt
 		t.ExtraData = make(map[string]interface{})
 	}
 
-	if err := oo.verifyUpdateIDToken(ctx, t, o.ProviderOptions["nonce"]); err != nil {
-		return nil, errmark.MarkUser(err)
+	// If code is empty we're doing an RFC8693 token exchange and then
+	// the ID token is optional. Otherwise, verify the ID token.
+	if code != "" {
+		if err := oo.verifyUpdateIDToken(ctx, t, o.ProviderOptions["nonce"]); err != nil {
+			return nil, errmark.MarkUser(err)
+		}
 	}
 
 	if err := oo.updateUserInfo(ctx, t); err != nil {
diff --git a/pkg/testutil/mock.go b/pkg/testutil/mock.go
index f48af8d..acc0cf0 100644
--- a/pkg/testutil/mock.go
+++ b/pkg/testutil/mock.go
@@ -7,6 +7,7 @@ import (
 	"fmt"
 	"net/http"
 	"net/http/httptest"
+	"net/url"
 	"sync"
 	"sync/atomic"
 	"time"
@@ -349,3 +350,69 @@ func MockFactory(opts ...MockOption) provider.FactoryFunc {
 
 	return m.factory
 }
+
+// tokenProvider is a local server that mocks RFC8693 token exchange
+type tokenProvider struct {
+	server *httptest.Server
+}
+
+func NewMockTokenProvider() *tokenProvider {
+	tp := new(tokenProvider)
+	tp.server = httptest.NewServer(tp)
+
+	return tp
+}
+
+func (tp *tokenProvider) GetServerURL() string {
+	return tp.server.URL
+}
+
+func (tp *tokenProvider) Close() {
+	tp.server.Close()
+}
+
+func (tp *tokenProvider) ServeHTTP(w http.ResponseWriter, r *http.Request) {
+	w.Header().Set("Content-Type", "application/json")
+
+	errmsg := ""
+
+	switch r.URL.Path {
+	case "/token":
+		grant_type := r.FormValue("grant_type")
+		tok := url.Values{}
+		if grant_type != "urn:ietf:params:oauth:grant-type:token-exchange" {
+			tok["scopes"] = []string{"scopea scopeb scopec"}
+			tok["audience"] = []string{"any"}
+		} else {
+			subject_token := r.FormValue("subject_token")
+			if subject_token == "" {
+				errmsg = "no subject_token"
+				break
+			}
+			params, err := url.ParseQuery(subject_token)
+			if err != nil {
+				errmsg = "could not parse subject_token"
+				break
+			}
+			scopes := r.FormValue("scope")
+			if scopes != "" {
+				tok["scopes"] = []string{scopes}
+			} else {
+				tok["scopes"] = params["scopes"]
+			}
+			audience := r.FormValue("audience")
+			if audience != "" {
+				tok["audience"] = []string{audience}
+			} else {
+				tok["audience"] = params["audience"]
+			}
+		}
+
+		// simple manual json encoding
+		_, _ = w.Write([]byte(`{"access_token": "` + tok.Encode() + `"}`))
+		return
+	default:
+		errmsg = fmt.Sprintf("unexpected path: %q", r.URL.Path)
+	}
+	_, _ = w.Write([]byte(`{"error": "` + errmsg + `"}`))
+}
