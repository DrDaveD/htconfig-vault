From abafe656fa87dacd542b25434f3b19db6c691dbd Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Thu, 6 Aug 2020 15:07:57 -0500
Subject: [PATCH 01/25] add direct_callback role option

---
 path_role.go | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/path_role.go b/path_role.go
index 8216b7e..b1fff9e 100644
--- a/path_role.go
+++ b/path_role.go
@@ -138,6 +138,10 @@ Defaults to 60 (1 minute) if set to 0 and can be disabled if set to -1.`,
 				Type:        framework.TypeCommaStringSlice,
 				Description: `Comma-separated list of allowed values for redirect_uri`,
 			},
+			"direct_callback": {
+				Type:        framework.TypeBool,
+				Description: `OIDC callback is direct from Authorization Server to vault`,
+			},
 			"verbose_oidc_logging": {
 				Type: framework.TypeBool,
 				Description: `Log received OIDC tokens and claims when debug-level logging is active. 
@@ -201,6 +205,7 @@ type jwtRole struct {
 	GroupsClaim         string                 `json:"groups_claim"`
 	OIDCScopes          []string               `json:"oidc_scopes"`
 	AllowedRedirectURIs []string               `json:"allowed_redirect_uris"`
+	DirectCallback      bool                   `json:"direct_callback"`
 	VerboseOIDCLogging  bool                   `json:"verbose_oidc_logging"`
 
 	// Deprecated by TokenParams
@@ -306,6 +311,7 @@ func (b *jwtAuthBackend) pathRoleRead(ctx context.Context, req *logical.Request,
 		"user_claim":            role.UserClaim,
 		"groups_claim":          role.GroupsClaim,
 		"allowed_redirect_uris": role.AllowedRedirectURIs,
+		"direct_callback":       role.DirectCallback,
 		"oidc_scopes":           role.OIDCScopes,
 		"verbose_oidc_logging":  role.VerboseOIDCLogging,
 	}
@@ -508,6 +514,10 @@ func (b *jwtAuthBackend) pathRoleCreateUpdate(ctx context.Context, req *logical.
 		role.AllowedRedirectURIs = allowedRedirectURIs.([]string)
 	}
 
+	if directCallbackRaw, ok := data.GetOk("direct_callback"); ok {
+		role.DirectCallback = directCallbackRaw.(bool)
+	}
+
 	if role.RoleType == "oidc" && len(role.AllowedRedirectURIs) == 0 {
 		return logical.ErrorResponse(
 			"'allowed_redirect_uris' must be set if 'role_type' is 'oidc' or unspecified."), nil

From 7032abafe83aa77944c9d6ceb10bd4f4649da0b6 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Thu, 6 Aug 2020 15:08:52 -0500
Subject: [PATCH 02/25] allow oidc/callback to be called directly from
 authorization server

---
 path_oidc.go | 65 ++++++++++++++++++++++++++++++++++++++--------------
 1 file changed, 48 insertions(+), 17 deletions(-)

diff --git a/path_oidc.go b/path_oidc.go
index 3634560..16a7908 100644
--- a/path_oidc.go
+++ b/path_oidc.go
@@ -64,6 +64,9 @@ func pathOIDC(b *jwtAuthBackend) []*framework.Path {
 				"client_nonce": {
 					Type: framework.TypeString,
 				},
+				"error_description": {
+					Type: framework.TypeString,
+				},
 			},
 
 			Operations: map[logical.Operation]framework.OperationHandler{
@@ -154,6 +157,19 @@ func (b *jwtAuthBackend) pathCallbackPost(ctx context.Context, req *logical.Requ
 	return resp, nil
 }
 
+func (b *jwtAuthBackend) loginFailedResponse(useHttp bool, msg string) (*logical.Response) {
+	if !useHttp {
+		return logical.ErrorResponse(errLoginFailed + " " + msg)
+	}
+	return &logical.Response{
+		Data: map[string]interface{}{
+			logical.HTTPContentType: "text/html",
+			logical.HTTPStatusCode:  http.StatusBadRequest,
+			logical.HTTPRawBody:     []byte(errorHTML(errLoginFailed, msg)),
+		},
+	}
+}
+
 func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request, d *framework.FieldData) (*logical.Response, error) {
 	config, err := b.config(ctx, req.Storage)
 	if err != nil {
@@ -170,14 +186,6 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 		return logical.ErrorResponse(errLoginFailed + " Expired or missing OAuth state."), nil
 	}
 
-	clientNonce := d.Get("client_nonce").(string)
-
-	// If a client_nonce was provided at the start of the auth process as part of the auth_url
-	// request, require that it is present and matching during the callback phase.
-	if state.clientNonce != "" && clientNonce != state.clientNonce {
-		return logical.ErrorResponse("invalid client_nonce"), nil
-	}
-
 	roleName := state.rolename
 	role, err := b.role(ctx, req.Storage, roleName)
 	if err != nil {
@@ -187,6 +195,22 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 		return logical.ErrorResponse(errLoginFailed + " Role could not be found"), nil
 	}
 
+	useHttp := role.DirectCallback
+
+	errorDescription := d.Get("error_description").(string)
+	if errorDescription != "" {
+		return b.loginFailedResponse(useHttp, errorDescription), nil
+	}
+
+	clientNonce := d.Get("client_nonce").(string)
+
+	// If a client_nonce was provided at the start of the auth process as part of the auth_url
+	// request, require that it is present and matching during the callback phase
+	// unless using the DirectCallback mode (when we instead check in poll_wait).
+	if state.clientNonce != "" && clientNonce != state.clientNonce && !role.DirectCallback {
+		return logical.ErrorResponse("invalid client_nonce"), nil
+	}
+
 	if len(role.TokenBoundCIDRs) > 0 {
 		if req.Connection == nil {
 			b.Logger().Warn("token bound CIDRs found but no connection information available for validation")
@@ -225,20 +249,20 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 
 	if code == "" {
 		if state.idToken == "" {
-			return logical.ErrorResponse(errLoginFailed + " No code or id_token received."), nil
+			return b.loginFailedResponse(useHttp, "No code or id_token received."), nil
 		}
 		rawToken = state.idToken
 	} else {
 		oauth2Token, err = oauth2Config.Exchange(oidcCtx, code)
 		if err != nil {
-			return logical.ErrorResponse(errLoginFailed+" Error exchanging oidc code: %q.", err.Error()), nil
+			return b.loginFailedResponse(useHttp, fmt.Sprintf("Error exchanging oidc code: %q.", err.Error())), nil
 		}
 
 		// Extract the ID Token from OAuth2 token.
 		var ok bool
 		rawToken, ok = oauth2Token.Extra("id_token").(string)
 		if !ok {
-			return logical.ErrorResponse(errTokenVerification + " No id_token found in response."), nil
+			return b.loginFailedResponse(useHttp, "No id_token found in response."), nil
 		}
 	}
 
@@ -249,11 +273,11 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 	// Parse and verify ID Token payload.
 	allClaims, err := b.verifyOIDCToken(ctx, config, role, rawToken)
 	if err != nil {
-		return logical.ErrorResponse("%s %s", errTokenVerification, err.Error()), nil
+		return b.loginFailedResponse(useHttp, fmt.Sprintf("%s %s", errTokenVerification, err.Error())), nil
 	}
 
 	if allClaims["nonce"] != state.nonce {
-		return logical.ErrorResponse(errTokenVerification + " Invalid ID token nonce."), nil
+		return b.loginFailedResponse(useHttp, "Invalid ID token nonce."), nil
 	}
 	delete(allClaims, "nonce")
 
@@ -281,12 +305,12 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 	}
 
 	if err := validateBoundClaims(b.Logger(), role.BoundClaimsType, role.BoundClaims, allClaims); err != nil {
-		return logical.ErrorResponse("error validating claims: %s", err.Error()), nil
+		return b.loginFailedResponse(useHttp, fmt.Sprintf("error validating claims: %s", err.Error())), nil
 	}
 
 	alias, groupAliases, err := b.createIdentity(allClaims, role)
 	if err != nil {
-		return logical.ErrorResponse(err.Error()), nil
+		return b.loginFailedResponse(useHttp, err.Error()), nil
 	}
 
 	tokenMetadata := map[string]string{"role": roleName}
@@ -315,8 +339,15 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 
 	role.PopulateTokenAuth(auth)
 
-	resp := &logical.Response{
-		Auth: auth,
+	resp := &logical.Response{}
+	if useHttp {
+		resp.Data = map[string]interface{} {
+			logical.HTTPContentType: "text/html",
+			logical.HTTPStatusCode:  http.StatusOK,
+			logical.HTTPRawBody:     []byte(successHTML),
+		}
+	} else {
+		resp.Auth = auth
 	}
 
 	return resp, nil

From 5836a8403f1d873180977fbc3af61a46df12e33c Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Thu, 6 Aug 2020 17:07:08 -0500
Subject: [PATCH 03/25] rename cli_responses.go to html_responses.go

---
 cli_responses.go => html_responses.go | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 rename cli_responses.go => html_responses.go (100%)

diff --git a/cli_responses.go b/html_responses.go
similarity index 100%
rename from cli_responses.go
rename to html_responses.go

From 90a7320978fbdc7aa0014bd0ae180b16e444c024 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Wed, 12 Aug 2020 17:53:41 -0500
Subject: [PATCH 04/25] add poll api

---
 backend.go   |   1 +
 path_oidc.go | 118 ++++++++++++++++++++++++++++++++++++---------------
 2 files changed, 85 insertions(+), 34 deletions(-)

diff --git a/backend.go b/backend.go
index b9bc079..ff3fa22 100644
--- a/backend.go
+++ b/backend.go
@@ -55,6 +55,7 @@ func backend() *jwtAuthBackend {
 				"login",
 				"oidc/auth_url",
 				"oidc/callback",
+				"oidc/poll",
 
 				// Uncomment to mount simple UI handler for local development
 				// "ui",
diff --git a/path_oidc.go b/path_oidc.go
index 16a7908..61ba925 100644
--- a/path_oidc.go
+++ b/path_oidc.go
@@ -3,7 +3,6 @@ package jwtauth
 import (
 	"context"
 	"encoding/json"
-	"errors"
 	"fmt"
 	"net/http"
 	"net/url"
@@ -45,6 +44,9 @@ type oidcState struct {
 	// clientNonce is used between Vault and the client/application (e.g. CLI) making the request,
 	// and is unrelated to the OIDC nonce above. It is optional.
 	clientNonce string
+
+	// this is for storing the response in direct callback mode
+	auth        *logical.Auth
 }
 
 func pathOIDC(b *jwtAuthBackend) []*framework.Path {
@@ -86,6 +88,26 @@ func pathOIDC(b *jwtAuthBackend) []*framework.Path {
 				},
 			},
 		},
+		{
+			Pattern: `oidc/poll`,
+			Fields: map[string]*framework.FieldSchema{
+				"state": {
+					Type: framework.TypeString,
+				},
+				"client_nonce": {
+					Type: framework.TypeString,
+				},
+			},
+			Operations: map[logical.Operation]framework.OperationHandler{
+				logical.ReadOperation: &framework.PathOperation{
+					Callback: b.pathPoll,
+					Summary:  "Poll endpoint to complete an OIDC login.",
+
+					// state is cached so don't process OIDC logins on perf standbys
+					ForwardPerformanceStandby: true,
+				},
+			},
+		},
 		{
 			Pattern: `oidc/auth_url`,
 			Fields: map[string]*framework.FieldSchema{
@@ -140,11 +162,14 @@ func (b *jwtAuthBackend) pathCallbackPost(ctx context.Context, req *logical.Requ
 	}
 
 	// Store the provided code and/or token into state, which must already exist.
-	state, err := b.amendState(stateID, code, idToken)
-	if err != nil {
+	state := b.getState(stateID)
+	if state == nil {
 		resp.Data[logical.HTTPRawBody] = []byte(errorHTML(errLoginFailed, "Expired or missing OAuth state."))
 		resp.Data[logical.HTTPStatusCode] = http.StatusBadRequest
 	} else {
+		state.code = code
+		state.idToken = idToken
+		b.setState(stateID, state)
 		mount := parseMount(state.redirectURI)
 		if mount == "" {
 			resp.Data[logical.HTTPRawBody] = []byte(errorHTML(errLoginFailed, "Invalid redirect path."))
@@ -157,7 +182,7 @@ func (b *jwtAuthBackend) pathCallbackPost(ctx context.Context, req *logical.Requ
 	return resp, nil
 }
 
-func (b *jwtAuthBackend) loginFailedResponse(useHttp bool, msg string) (*logical.Response) {
+func loginFailedResponse(useHttp bool, msg string) (*logical.Response) {
 	if !useHttp {
 		return logical.ErrorResponse(errLoginFailed + " " + msg)
 	}
@@ -181,7 +206,7 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 
 	stateID := d.Get("state").(string)
 
-	state := b.verifyState(stateID)
+	state := b.getState(stateID)
 	if state == nil {
 		return logical.ErrorResponse(errLoginFailed + " Expired or missing OAuth state."), nil
 	}
@@ -189,24 +214,30 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 	roleName := state.rolename
 	role, err := b.role(ctx, req.Storage, roleName)
 	if err != nil {
+		b.deleteState(stateID)
 		return nil, err
 	}
 	if role == nil {
+		b.deleteState(stateID)
 		return logical.ErrorResponse(errLoginFailed + " Role could not be found"), nil
 	}
 
 	useHttp := role.DirectCallback
+	if !useHttp {
+		// state is only accessed once when not using direct callback
+		b.deleteState(stateID)
+	}
 
 	errorDescription := d.Get("error_description").(string)
 	if errorDescription != "" {
-		return b.loginFailedResponse(useHttp, errorDescription), nil
+		return loginFailedResponse(useHttp, errorDescription), nil
 	}
 
 	clientNonce := d.Get("client_nonce").(string)
 
 	// If a client_nonce was provided at the start of the auth process as part of the auth_url
 	// request, require that it is present and matching during the callback phase
-	// unless using the DirectCallback mode (when we instead check in poll_wait).
+	// unless using the DirectCallback mode (when we instead check in poll).
 	if state.clientNonce != "" && clientNonce != state.clientNonce && !role.DirectCallback {
 		return logical.ErrorResponse("invalid client_nonce"), nil
 	}
@@ -249,20 +280,20 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 
 	if code == "" {
 		if state.idToken == "" {
-			return b.loginFailedResponse(useHttp, "No code or id_token received."), nil
+			return loginFailedResponse(useHttp, "No code or id_token received."), nil
 		}
 		rawToken = state.idToken
 	} else {
 		oauth2Token, err = oauth2Config.Exchange(oidcCtx, code)
 		if err != nil {
-			return b.loginFailedResponse(useHttp, fmt.Sprintf("Error exchanging oidc code: %q.", err.Error())), nil
+			return loginFailedResponse(useHttp, fmt.Sprintf("Error exchanging oidc code: %q.", err.Error())), nil
 		}
 
 		// Extract the ID Token from OAuth2 token.
 		var ok bool
 		rawToken, ok = oauth2Token.Extra("id_token").(string)
 		if !ok {
-			return b.loginFailedResponse(useHttp, "No id_token found in response."), nil
+			return loginFailedResponse(useHttp, "No id_token found in response."), nil
 		}
 	}
 
@@ -273,11 +304,11 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 	// Parse and verify ID Token payload.
 	allClaims, err := b.verifyOIDCToken(ctx, config, role, rawToken)
 	if err != nil {
-		return b.loginFailedResponse(useHttp, fmt.Sprintf("%s %s", errTokenVerification, err.Error())), nil
+		return loginFailedResponse(useHttp, fmt.Sprintf("%s %s", errTokenVerification, err.Error())), nil
 	}
 
 	if allClaims["nonce"] != state.nonce {
-		return b.loginFailedResponse(useHttp, "Invalid ID token nonce."), nil
+		return loginFailedResponse(useHttp, "Invalid ID token nonce."), nil
 	}
 	delete(allClaims, "nonce")
 
@@ -305,12 +336,12 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 	}
 
 	if err := validateBoundClaims(b.Logger(), role.BoundClaimsType, role.BoundClaims, allClaims); err != nil {
-		return b.loginFailedResponse(useHttp, fmt.Sprintf("error validating claims: %s", err.Error())), nil
+		return loginFailedResponse(useHttp, fmt.Sprintf("error validating claims: %s", err.Error())), nil
 	}
 
 	alias, groupAliases, err := b.createIdentity(allClaims, role)
 	if err != nil {
-		return b.loginFailedResponse(useHttp, err.Error()), nil
+		return loginFailedResponse(useHttp, err.Error()), nil
 	}
 
 	tokenMetadata := map[string]string{"role": roleName}
@@ -341,6 +372,8 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 
 	resp := &logical.Response{}
 	if useHttp {
+		state.auth = auth
+		b.setState(stateID, state)
 		resp.Data = map[string]interface{} {
 			logical.HTTPContentType: "text/html",
 			logical.HTTPStatusCode:  http.StatusOK,
@@ -353,6 +386,33 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 	return resp, nil
 }
 
+func (b *jwtAuthBackend) pathPoll(ctx context.Context, req *logical.Request, d *framework.FieldData) (*logical.Response, error) {
+	stateID := d.Get("state").(string)
+
+	state := b.getState(stateID)
+	if state == nil {
+		return logical.ErrorResponse(errLoginFailed + " Expired or missing OAuth state."), nil
+	}
+
+	clientNonce := d.Get("client_nonce").(string)
+
+	if state.clientNonce != "" && clientNonce != state.clientNonce {
+		b.deleteState(stateID)
+		return logical.ErrorResponse("invalid client_nonce"), nil
+	}
+
+	if state.auth == nil {
+		// Return the same response as oauth 2.0 device flow in RFC8628
+		return logical.ErrorResponse("authorization_pending"), nil
+	}
+
+	b.deleteState(stateID)
+	resp := &logical.Response{
+		Auth: state.auth,
+	}
+	return resp, nil
+}
+
 // authURL returns a URL used for redirection to receive an authorization code.
 // This path requires a role name, or that a default_role has been configured.
 // Because this endpoint is unauthenticated, the response to invalid or non-OIDC
@@ -467,6 +527,10 @@ func (b *jwtAuthBackend) authURL(ctx context.Context, req *logical.Request, d *f
 		fmt.Sprintf("response_type=%s", url.QueryEscape(rt)), 1)
 
 	resp.Data["auth_url"] = urlStr
+	if role.DirectCallback {
+		resp.Data["state"] = stateID
+		resp.Data["poll_interval"] = "5"
+	}
 
 	return resp, nil
 }
@@ -494,35 +558,21 @@ func (b *jwtAuthBackend) createState(rolename, redirectURI, clientNonce string)
 	return stateID, nonce, nil
 }
 
-func (b *jwtAuthBackend) amendState(stateID, code, idToken string) (*oidcState, error) {
-	stateRaw, ok := b.oidcStates.Get(stateID)
-	if !ok {
-		return nil, errors.New("OIDC state not found")
-	}
-
-	state := stateRaw.(*oidcState)
-	state.code = code
-	state.idToken = idToken
-
+func (b *jwtAuthBackend) setState(stateID string, state *oidcState) {
 	b.oidcStates.SetDefault(stateID, state)
-
-	return state, nil
 }
 
-// verifyState tests whether the provided state ID is valid and returns the
-// associated state object if so. A nil state is returned if the ID is not found
-// or expired. The state should only ever be retrieved once and is deleted as
-// part of this request.
-func (b *jwtAuthBackend) verifyState(stateID string) *oidcState {
-	defer b.oidcStates.Delete(stateID)
-
+func (b *jwtAuthBackend) getState(stateID string) *oidcState {
 	if stateRaw, ok := b.oidcStates.Get(stateID); ok {
 		return stateRaw.(*oidcState)
 	}
-
 	return nil
 }
 
+func (b *jwtAuthBackend) deleteState(stateID string) {
+	b.oidcStates.Delete(stateID)
+}
+
 // validRedirect checks whether uri is in allowed using special handling for loopback uris.
 // Ref: https://tools.ietf.org/html/rfc8252#section-7.3
 func validRedirect(uri string, allowed []string) bool {

From f7c414479ea926e52cc3b70f028b408c85f22f3d Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Wed, 12 Aug 2020 17:53:56 -0500
Subject: [PATCH 05/25] support direct callbackmode

---
 cli.go | 130 +++++++++++++++++++++++++++++++++++++++++++++++----------
 1 file changed, 107 insertions(+), 23 deletions(-)

diff --git a/cli.go b/cli.go
index 91cb6b9..9351559 100644
--- a/cli.go
+++ b/cli.go
@@ -6,12 +6,14 @@ import (
 	"io/ioutil"
 	"net"
 	"net/http"
+	"net/url"
 	"os"
 	"os/exec"
 	"os/signal"
 	"path"
 	"regexp"
 	"runtime"
+	"strconv"
 	"strings"
 	"time"
 
@@ -22,6 +24,7 @@ import (
 const defaultMount = "oidc"
 const defaultListenAddress = "localhost"
 const defaultPort = "8250"
+const defaultCallbackMode = "cli"
 const defaultCallbackHost = "localhost"
 const defaultCallbackMethod = "http"
 
@@ -57,36 +60,87 @@ func (h *CLIHandler) Auth(c *api.Client, m map[string]string) (*api.Secret, erro
 		port = defaultPort
 	}
 
+	var vaultURL *url.URL
+	callbackMode, ok := m["callbackmode"]
+	if !ok {
+		callbackMode = defaultCallbackMode
+	} else if callbackMode == "direct" {
+		vaultAddr := os.Getenv("VAULT_ADDR")
+		if vaultAddr != "" {
+			vaultURL, _ = url.Parse(vaultAddr)
+		}
+	}
+
 	callbackHost, ok := m["callbackhost"]
 	if !ok {
-		callbackHost = defaultCallbackHost
+		if vaultURL != nil {
+			callbackHost = vaultURL.Hostname()
+		} else {
+			callbackHost = defaultCallbackHost
+		}
 	}
 
 	callbackMethod, ok := m["callbackmethod"]
 	if !ok {
-		callbackMethod = defaultCallbackMethod
+		if vaultURL != nil {
+			callbackMethod = vaultURL.Scheme
+		} else {
+			callbackMethod = defaultCallbackMethod
+		}
 	}
 
 	callbackPort, ok := m["callbackport"]
 	if !ok {
-		callbackPort = port
+		if vaultURL != nil {
+			callbackPort = vaultURL.Port() + "/v1/auth/" + mount
+		} else {
+			callbackPort = port
+		}
 	}
 
 	role := m["role"]
 
-	authURL, clientNonce, err := fetchAuthURL(c, role, mount, callbackPort, callbackMethod, callbackHost)
+	authURL, clientNonce, secret, err := fetchAuthURL(c, role, mount, callbackPort, callbackMethod, callbackHost)
 	if err != nil {
 		return nil, err
 	}
 
-	// Set up callback handler
-	http.HandleFunc("/oidc/callback", callbackHandler(c, mount, clientNonce, doneCh))
+	var pollInterval string
+	var interval int
+	var state string
+	var listener net.Listener
 
-	listener, err := net.Listen("tcp", listenAddress+":"+port)
-	if err != nil {
-		return nil, err
+	if secret != nil {
+		pollInterval, _ = secret.Data["poll_interval"].(string)
+		state, _ = secret.Data["state"].(string)
+	}
+	if callbackMode == "direct" {
+		if state == "" {
+			return nil, errors.New("no state returned in direct callback mode")
+		}
+		if pollInterval == "" {
+			return nil, errors.New("no poll_interval returned in direct callback mode")
+		}
+		interval, err = strconv.Atoi(pollInterval)
+		if err != nil {
+			return nil, errors.New("cannot convert poll_interval " + pollInterval + " to integer")
+		}
+	} else {
+		if state != "" {
+			return nil, errors.New("state returned in cli callback mode, try direct")
+		}
+		if pollInterval != "" {
+			return nil, errors.New("poll_interval returned in cli callback mode")
+		}
+		// Set up callback handler
+		http.HandleFunc("/oidc/callback", callbackHandler(c, mount, clientNonce, doneCh))
+
+		listener, err := net.Listen("tcp", listenAddress+":"+port)
+		if err != nil {
+			return nil, err
+		}
+		defer listener.Close()
 	}
-	defer listener.Close()
 
 	// Open the default browser to the callback URL.
 	fmt.Fprintf(os.Stderr, "Complete the login via your OIDC provider. Launching browser to:\n\n    %s\n\n\n", authURL)
@@ -94,6 +148,26 @@ func (h *CLIHandler) Auth(c *api.Client, m map[string]string) (*api.Secret, erro
 		fmt.Fprintf(os.Stderr, "Error attempting to automatically open browser: '%s'.\nPlease visit the authorization URL manually.", err)
 	}
 
+	if callbackMode == "direct" {
+		data := map[string][]string{
+			"state":        {state},
+			"client_nonce": {clientNonce},
+		}
+		pollUrl := fmt.Sprintf("auth/%s/oidc/poll", mount)
+		for {
+			time.Sleep(time.Duration(interval) * time.Second)
+
+			secret, err := c.Logical().ReadWithData(pollUrl, data)
+			if err == nil {
+				return secret, nil
+			}
+			if !strings.HasSuffix(err.Error(), "authorization_pending") {
+				return nil, err
+			}
+			// authorization is pending, try again
+		}
+	}
+
 	// Start local server
 	go func() {
 		err := http.Serve(listener, nil)
@@ -160,12 +234,12 @@ func callbackHandler(c *api.Client, mount string, clientNonce string, doneCh cha
 	}
 }
 
-func fetchAuthURL(c *api.Client, role, mount, callbackport string, callbackMethod string, callbackHost string) (string, string, error) {
+func fetchAuthURL(c *api.Client, role, mount, callbackport string, callbackMethod string, callbackHost string) (string, string, *api.Secret, error) {
 	var authURL string
 
 	clientNonce, err := base62.Random(20)
 	if err != nil {
-		return "", "", err
+		return "", "", nil, err
 	}
 
 	data := map[string]interface{}{
@@ -176,7 +250,7 @@ func fetchAuthURL(c *api.Client, role, mount, callbackport string, callbackMetho
 
 	secret, err := c.Logical().Write(fmt.Sprintf("auth/%s/oidc/auth_url", mount), data)
 	if err != nil {
-		return "", "", err
+		return "", "", nil, err
 	}
 
 	if secret != nil {
@@ -184,10 +258,10 @@ func fetchAuthURL(c *api.Client, role, mount, callbackport string, callbackMetho
 	}
 
 	if authURL == "" {
-		return "", "", fmt.Errorf("Unable to authorize role %q. Check Vault logs for more information.", role)
+		return "", "", nil, fmt.Errorf("Unable to authorize role %q. Check Vault logs for more information.", role)
 	}
 
-	return authURL, clientNonce, nil
+	return authURL, clientNonce, secret, nil
 }
 
 // isWSL tests if the binary is being run in Windows Subsystem for Linux
@@ -274,28 +348,38 @@ Usage: vault login -method=oidc [CONFIG K=V...]
 
           https://accounts.google.com/o/oauth2/v2/...
 
-  The default browser will be opened for the user to complete the login. Alternatively,
-  the user may visit the provided URL directly.
+  The default browser will be opened for the user to complete the login. 
+  Alternatively, the user may visit the provided URL directly.
 
 Configuration:
 
   role=<string>
-      Vault role of type "OIDC" to use for authentication.
+    Vault role of type "OIDC" to use for authentication.
+
+  callbackmode=<string>
+    Mode of callback: "direct" for direct connection to Vault or "cli" for
+    connection to command line client (default: cli).
 
   listenaddress=<string>
-    Optional address to bind the OIDC callback listener to (default: localhost).
+    Optional address to bind the OIDC callback listener to in cli callback
+    mode (default: localhost).
 
   port=<string>
-    Optional localhost port to use for OIDC callback (default: 8250).
+    Optional localhost port to use for OIDC callback in cli callback mode
+    (default: 8250).
 
   callbackmethod=<string>
-    Optional method to to use in OIDC redirect_uri (default: http).
+    Optional method to use in OIDC redirect_uri (default: the method from
+    $VAULT_ADDR in direct callback mode, else http)
 
   callbackhost=<string>
-    Optional callback host address to use in OIDC redirect_uri (default: localhost).
+    Optional callback host address to use in OIDC redirect_uri (default:
+    the host from $VAULT_ADDR in direct callback mode, else localhost).
 
   callbackport=<string>
-      Optional port to to use in OIDC redirect_uri (default: the value set for port).
+    Optional port to use in OIDC redirect_uri (default: the value set for
+    port in cli callback mode, else the port from $VAULT_ADDR with an added
+    /v1/auth/<path> where <path> is from the login -path option).
 `
 
 	return strings.TrimSpace(help)

From fc008ccfb6d3fe7942a8e5cc376152eae95e4dfb Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Thu, 13 Aug 2020 11:18:24 -0500
Subject: [PATCH 06/25] use callback_mode=direct instead of
 direct_callback=true

---
 path_oidc.go | 11 +++++++----
 path_role.go | 21 ++++++++++++++-------
 2 files changed, 21 insertions(+), 11 deletions(-)

diff --git a/path_oidc.go b/path_oidc.go
index 61ba925..8667843 100644
--- a/path_oidc.go
+++ b/path_oidc.go
@@ -222,7 +222,10 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 		return logical.ErrorResponse(errLoginFailed + " Role could not be found"), nil
 	}
 
-	useHttp := role.DirectCallback
+	useHttp := false
+	if role.CallbackMode == callbackModeDirect {
+		useHttp = true
+	}
 	if !useHttp {
 		// state is only accessed once when not using direct callback
 		b.deleteState(stateID)
@@ -237,8 +240,8 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 
 	// If a client_nonce was provided at the start of the auth process as part of the auth_url
 	// request, require that it is present and matching during the callback phase
-	// unless using the DirectCallback mode (when we instead check in poll).
-	if state.clientNonce != "" && clientNonce != state.clientNonce && !role.DirectCallback {
+	// unless using the direct callback mode (when we instead check in poll).
+	if state.clientNonce != "" && clientNonce != state.clientNonce && !useHttp {
 		return logical.ErrorResponse("invalid client_nonce"), nil
 	}
 
@@ -527,7 +530,7 @@ func (b *jwtAuthBackend) authURL(ctx context.Context, req *logical.Request, d *f
 		fmt.Sprintf("response_type=%s", url.QueryEscape(rt)), 1)
 
 	resp.Data["auth_url"] = urlStr
-	if role.DirectCallback {
+	if role.CallbackMode == callbackModeDirect {
 		resp.Data["state"] = stateID
 		resp.Data["poll_interval"] = "5"
 	}
diff --git a/path_role.go b/path_role.go
index b1fff9e..1c19794 100644
--- a/path_role.go
+++ b/path_role.go
@@ -22,6 +22,8 @@ const (
 	claimDefaultLeeway    = 150
 	boundClaimsTypeString = "string"
 	boundClaimsTypeGlob   = "glob"
+	callbackModeDirect    = "direct"
+	callbackModeClient    = "client"
 )
 
 func pathRoleList(b *jwtAuthBackend) *framework.Path {
@@ -138,9 +140,10 @@ Defaults to 60 (1 minute) if set to 0 and can be disabled if set to -1.`,
 				Type:        framework.TypeCommaStringSlice,
 				Description: `Comma-separated list of allowed values for redirect_uri`,
 			},
-			"direct_callback": {
-				Type:        framework.TypeBool,
-				Description: `OIDC callback is direct from Authorization Server to vault`,
+			"callback_mode": {
+				Type:        framework.TypeString,
+				Description: `OIDC callback mode from Authorization Server: allowed values are 'direct' to Vault or 'client', default 'client'`,
+				Default:     callbackModeClient,
 			},
 			"verbose_oidc_logging": {
 				Type: framework.TypeBool,
@@ -205,7 +208,7 @@ type jwtRole struct {
 	GroupsClaim         string                 `json:"groups_claim"`
 	OIDCScopes          []string               `json:"oidc_scopes"`
 	AllowedRedirectURIs []string               `json:"allowed_redirect_uris"`
-	DirectCallback      bool                   `json:"direct_callback"`
+	CallbackMode        string                 `json:"callback_mode"`
 	VerboseOIDCLogging  bool                   `json:"verbose_oidc_logging"`
 
 	// Deprecated by TokenParams
@@ -311,7 +314,7 @@ func (b *jwtAuthBackend) pathRoleRead(ctx context.Context, req *logical.Request,
 		"user_claim":            role.UserClaim,
 		"groups_claim":          role.GroupsClaim,
 		"allowed_redirect_uris": role.AllowedRedirectURIs,
-		"direct_callback":       role.DirectCallback,
+		"callback_mode":         role.CallbackMode,
 		"oidc_scopes":           role.OIDCScopes,
 		"verbose_oidc_logging":  role.VerboseOIDCLogging,
 	}
@@ -514,8 +517,12 @@ func (b *jwtAuthBackend) pathRoleCreateUpdate(ctx context.Context, req *logical.
 		role.AllowedRedirectURIs = allowedRedirectURIs.([]string)
 	}
 
-	if directCallbackRaw, ok := data.GetOk("direct_callback"); ok {
-		role.DirectCallback = directCallbackRaw.(bool)
+	callbackMode := data.Get("callback_mode").(string)
+	switch callbackMode {
+	case callbackModeDirect, callbackModeClient:
+		role.CallbackMode = callbackMode
+	default:
+		return logical.ErrorResponse("invalid 'callback_mode': %s", callbackMode), nil
 	}
 
 	if role.RoleType == "oidc" && len(role.AllowedRedirectURIs) == 0 {

From faabd3b02565506163b9ce69a2f4f89a8f08f4f2 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Thu, 13 Aug 2020 11:18:45 -0500
Subject: [PATCH 07/25] use callbackmode=client instead of callbackmode=cli

---
 cli.go | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/cli.go b/cli.go
index 9351559..514efc7 100644
--- a/cli.go
+++ b/cli.go
@@ -24,7 +24,7 @@ import (
 const defaultMount = "oidc"
 const defaultListenAddress = "localhost"
 const defaultPort = "8250"
-const defaultCallbackMode = "cli"
+const defaultCallbackMode = "client"
 const defaultCallbackHost = "localhost"
 const defaultCallbackMethod = "http"
 
@@ -357,8 +357,8 @@ Configuration:
     Vault role of type "OIDC" to use for authentication.
 
   callbackmode=<string>
-    Mode of callback: "direct" for direct connection to Vault or "cli" for
-    connection to command line client (default: cli).
+    Mode of callback: "direct" for direct connection to Vault or "client"
+    for connection to command line client (default: client).
 
   listenaddress=<string>
     Optional address to bind the OIDC callback listener to in cli callback

From f00a280d07c02959546c53221d75aaf32684f5be Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Thu, 13 Aug 2020 11:53:47 -0500
Subject: [PATCH 08/25] complete the conversion of cli callbackmode to client

---
 cli.go | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/cli.go b/cli.go
index 514efc7..167f84b 100644
--- a/cli.go
+++ b/cli.go
@@ -361,11 +361,11 @@ Configuration:
     for connection to command line client (default: client).
 
   listenaddress=<string>
-    Optional address to bind the OIDC callback listener to in cli callback
+    Optional address to bind the OIDC callback listener to in client callback
     mode (default: localhost).
 
   port=<string>
-    Optional localhost port to use for OIDC callback in cli callback mode
+    Optional localhost port to use for OIDC callback in client callback mode
     (default: 8250).
 
   callbackmethod=<string>
@@ -378,8 +378,8 @@ Configuration:
 
   callbackport=<string>
     Optional port to use in OIDC redirect_uri (default: the value set for
-    port in cli callback mode, else the port from $VAULT_ADDR with an added
-    /v1/auth/<path> where <path> is from the login -path option).
+    port in client callback mode, else the port from $VAULT_ADDR with an
+    added /v1/auth/<path> where <path> is from the login -path option).
 `
 
 	return strings.TrimSpace(help)

From 770b121c932b6eeafd7a61e55d8701b00a7e6b2f Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Mon, 17 Aug 2020 10:44:13 -0500
Subject: [PATCH 09/25] change another cli->client callback mode

---
 cli.go | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/cli.go b/cli.go
index 167f84b..17533d5 100644
--- a/cli.go
+++ b/cli.go
@@ -127,10 +127,10 @@ func (h *CLIHandler) Auth(c *api.Client, m map[string]string) (*api.Secret, erro
 		}
 	} else {
 		if state != "" {
-			return nil, errors.New("state returned in cli callback mode, try direct")
+			return nil, errors.New("state returned in client callback mode, try direct")
 		}
 		if pollInterval != "" {
-			return nil, errors.New("poll_interval returned in cli callback mode")
+			return nil, errors.New("poll_interval returned in client callback mode")
 		}
 		// Set up callback handler
 		http.HandleFunc("/oidc/callback", callbackHandler(c, mount, clientNonce, doneCh))

From 8e2f534d70e30ae400cf21ba44e8419d112d2d42 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Fri, 21 Aug 2020 11:45:35 -0500
Subject: [PATCH 10/25] fix test for callback_mode=client

---
 path_role_test.go | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/path_role_test.go b/path_role_test.go
index e5cef59..e1f299a 100644
--- a/path_role_test.go
+++ b/path_role_test.go
@@ -85,6 +85,7 @@ func TestPath_Create(t *testing.T) {
 			NumUses:             12,
 			BoundCIDRs:          []*sockaddr.SockAddrMarshaler{{SockAddr: expectedSockAddr}},
 			AllowedRedirectURIs: []string(nil),
+			CallbackMode:        "client",
 		}
 
 		req := &logical.Request{
@@ -557,6 +558,7 @@ func TestPath_OIDCCreate(t *testing.T) {
 				"bar": "baz",
 			},
 			AllowedRedirectURIs: []string{"https://example.com", "http://localhost:8250"},
+			CallbackMode:    "client",
 			ClaimMappings: map[string]string{
 				"foo": "a",
 				"bar": "b",
@@ -763,6 +765,7 @@ func TestPath_Read(t *testing.T) {
 		"bound_subject":           "testsub",
 		"bound_audiences":         []string{"vault"},
 		"allowed_redirect_uris":   []string{"http://127.0.0.1"},
+		"callback_mode":           "client",
 		"oidc_scopes":             []string{"email", "profile"},
 		"user_claim":              "user",
 		"groups_claim":            "groups",

From 18c36965c977d3309cae5bd94553ef62388812ef Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Fri, 28 Aug 2020 14:18:42 -0500
Subject: [PATCH 11/25] add test for oidc/poll api in direct callback mode

---
 path_oidc_test.go | 59 +++++++++++++++++++++++++++++++++++------------
 1 file changed, 44 insertions(+), 15 deletions(-)

diff --git a/path_oidc_test.go b/path_oidc_test.go
index fafc132..52e6fa7 100644
--- a/path_oidc_test.go
+++ b/path_oidc_test.go
@@ -212,8 +212,18 @@ func TestOIDC_Callback(t *testing.T) {
 	t.Run("successful login", func(t *testing.T) {
 
 		// run test with and without bound_cidrs configured
-		for _, useBoundCIDRs := range []bool{false, true} {
-			b, storage, s := getBackendAndServer(t, useBoundCIDRs)
+		//   and with and without direct callback mode
+		for i := 1; i <= 3; i++ {
+			var useBoundCIDRs bool
+			var callbackMode string
+
+			if i == 2 {
+				useBoundCIDRs = true
+			} else if i == 3 {
+				callbackMode = "direct"
+			}
+
+			b, storage, s := getBackendAndServer(t, useBoundCIDRs, callbackMode)
 			defer s.server.Close()
 
 			// get auth_url
@@ -251,8 +261,8 @@ func TestOIDC_Callback(t *testing.T) {
 				Path:      "oidc/callback",
 				Storage:   storage,
 				Data: map[string]interface{}{
-					"state": state,
-					"code":  "abc",
+					"state":       state,
+					"code":        "abc",
 				},
 				Connection: &logical.Connection{
 					RemoteAddr: "127.0.0.42",
@@ -264,6 +274,21 @@ func TestOIDC_Callback(t *testing.T) {
 				t.Fatal(err)
 			}
 
+			if callbackMode == "direct" {
+				req = &logical.Request{
+					Operation: logical.ReadOperation,
+					Path:      "oidc/poll",
+					Storage:   storage,
+					Data: map[string]interface{}{
+						"state": state,
+					},
+				}
+				resp, err = b.HandleRequest(context.Background(), req)
+				if err != nil {
+					t.Fatal(err)
+				}
+			}
+
 			expected := &logical.Auth{
 				LeaseOptions: logical.LeaseOptions{
 					Renewable: true,
@@ -309,7 +334,7 @@ func TestOIDC_Callback(t *testing.T) {
 	})
 
 	t.Run("failed login - bad nonce", func(t *testing.T) {
-		b, storage, s := getBackendAndServer(t, false)
+		b, storage, s := getBackendAndServer(t, false, "")
 		defer s.server.Close()
 
 		// get auth_url
@@ -361,7 +386,7 @@ func TestOIDC_Callback(t *testing.T) {
 	})
 
 	t.Run("failed login - bound claim mismatch", func(t *testing.T) {
-		b, storage, s := getBackendAndServer(t, false)
+		b, storage, s := getBackendAndServer(t, false, "")
 		defer s.server.Close()
 
 		// get auth_url
@@ -414,7 +439,7 @@ func TestOIDC_Callback(t *testing.T) {
 	})
 
 	t.Run("missing state", func(t *testing.T) {
-		b, storage, s := getBackendAndServer(t, false)
+		b, storage, s := getBackendAndServer(t, false, "")
 		defer s.server.Close()
 
 		req := &logical.Request{
@@ -433,7 +458,7 @@ func TestOIDC_Callback(t *testing.T) {
 	})
 
 	t.Run("unknown state", func(t *testing.T) {
-		b, storage, s := getBackendAndServer(t, false)
+		b, storage, s := getBackendAndServer(t, false, "")
 		defer s.server.Close()
 
 		req := &logical.Request{
@@ -455,7 +480,7 @@ func TestOIDC_Callback(t *testing.T) {
 	})
 
 	t.Run("valid state, missing code", func(t *testing.T) {
-		b, storage, s := getBackendAndServer(t, false)
+		b, storage, s := getBackendAndServer(t, false, "")
 		defer s.server.Close()
 
 		// get auth_url
@@ -497,7 +522,7 @@ func TestOIDC_Callback(t *testing.T) {
 	})
 
 	t.Run("failed code exchange", func(t *testing.T) {
-		b, storage, s := getBackendAndServer(t, false)
+		b, storage, s := getBackendAndServer(t, false, "")
 		defer s.server.Close()
 
 		// get auth_url
@@ -543,7 +568,7 @@ func TestOIDC_Callback(t *testing.T) {
 	})
 
 	t.Run("no response from provider", func(t *testing.T) {
-		b, storage, s := getBackendAndServer(t, false)
+		b, storage, s := getBackendAndServer(t, false, "")
 
 		// get auth_url
 		data := map[string]interface{}{
@@ -589,7 +614,7 @@ func TestOIDC_Callback(t *testing.T) {
 	})
 
 	t.Run("test bad address", func(t *testing.T) {
-		b, storage, s := getBackendAndServer(t, true)
+		b, storage, s := getBackendAndServer(t, true, "")
 		defer s.server.Close()
 
 		s.code = "abc"
@@ -634,7 +659,7 @@ func TestOIDC_Callback(t *testing.T) {
 	})
 
 	t.Run("test invalid client_id", func(t *testing.T) {
-		b, storage, s := getBackendAndServer(t, false)
+		b, storage, s := getBackendAndServer(t, false, "")
 		defer s.server.Close()
 
 		s.code = "abc"
@@ -687,7 +712,7 @@ func TestOIDC_Callback(t *testing.T) {
 	})
 
 	t.Run("client_nonce", func(t *testing.T) {
-		b, storage, s := getBackendAndServer(t, false)
+		b, storage, s := getBackendAndServer(t, false, "")
 		defer s.server.Close()
 
 		// General behavior is that if a client_nonce is provided during the authURL phase
@@ -943,7 +968,7 @@ func TestOIDC_ValidRedirect(t *testing.T) {
 	}
 }
 
-func getBackendAndServer(t *testing.T, boundCIDRs bool) (logical.Backend, logical.Storage, *oidcProvider) {
+func getBackendAndServer(t *testing.T, boundCIDRs bool, callbackMode string) (logical.Backend, logical.Storage, *oidcProvider) {
 	b, storage := getBackend(t)
 	s := newOIDCProvider(t)
 	s.clientID = "abc"
@@ -1002,6 +1027,10 @@ func getBackendAndServer(t *testing.T, boundCIDRs bool) (logical.Backend, logica
 		data["bound_cidrs"] = "127.0.0.42"
 	}
 
+	if callbackMode != "" {
+		data["callback_mode"] = callbackMode
+	}
+
 	req = &logical.Request{
 		Operation: logical.CreateOperation,
 		Path:      "role/test",

From 760bb7220d6d5e6262f4bc193890dab76f14d219 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Fri, 28 Aug 2020 17:36:08 -0500
Subject: [PATCH 12/25] require client_nonce with direct callback mode, change
 poll from Read to Update, and make callback api only callable once

---
 path_oidc.go | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/path_oidc.go b/path_oidc.go
index 8667843..3f7cc56 100644
--- a/path_oidc.go
+++ b/path_oidc.go
@@ -99,7 +99,7 @@ func pathOIDC(b *jwtAuthBackend) []*framework.Path {
 				},
 			},
 			Operations: map[logical.Operation]framework.OperationHandler{
-				logical.ReadOperation: &framework.PathOperation{
+				logical.UpdateOperation: &framework.PathOperation{
 					Callback: b.pathPoll,
 					Summary:  "Poll endpoint to complete an OIDC login.",
 
@@ -121,7 +121,7 @@ func pathOIDC(b *jwtAuthBackend) []*framework.Path {
 				},
 				"client_nonce": {
 					Type:        framework.TypeString,
-					Description: "Optional client-provided nonce that must match during callback, if present.",
+					Description: "Client-provided nonce that must match during callback, if present. Required only in direct callback mode.",
 				},
 			},
 			Operations: map[logical.Operation]framework.OperationHandler{
@@ -207,7 +207,7 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 	stateID := d.Get("state").(string)
 
 	state := b.getState(stateID)
-	if state == nil {
+	if state == nil || state.auth != nil {
 		return logical.ErrorResponse(errLoginFailed + " Expired or missing OAuth state."), nil
 	}
 
@@ -455,8 +455,6 @@ func (b *jwtAuthBackend) authURL(ctx context.Context, req *logical.Request, d *f
 		return logical.ErrorResponse("missing redirect_uri"), nil
 	}
 
-	clientNonce := d.Get("client_nonce").(string)
-
 	role, err := b.role(ctx, req.Storage, roleName)
 	if err != nil {
 		return nil, err
@@ -465,6 +463,11 @@ func (b *jwtAuthBackend) authURL(ctx context.Context, req *logical.Request, d *f
 		return logical.ErrorResponse("role %q could not be found", roleName), nil
 	}
 
+	clientNonce := d.Get("client_nonce").(string)
+	if clientNonce == "" && role.CallbackMode != callbackModeClient {
+		return logical.ErrorResponse("missing client_nonce"), nil
+	}
+
 	if !validRedirect(redirectURI, role.AllowedRedirectURIs) {
 		logger.Warn("unauthorized redirect_uri", "redirect_uri", redirectURI)
 		return resp, nil

From d1797a2964063eaf13177008816b979140662509 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Fri, 28 Aug 2020 17:36:43 -0500
Subject: [PATCH 13/25] use Write instead of ReadWithData for poll api call

---
 cli.go | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/cli.go b/cli.go
index 17533d5..c7bab2c 100644
--- a/cli.go
+++ b/cli.go
@@ -149,15 +149,15 @@ func (h *CLIHandler) Auth(c *api.Client, m map[string]string) (*api.Secret, erro
 	}
 
 	if callbackMode == "direct" {
-		data := map[string][]string{
-			"state":        {state},
-			"client_nonce": {clientNonce},
+		data := map[string]interface{}{
+			"state":        state,
+			"client_nonce": clientNonce,
 		}
 		pollUrl := fmt.Sprintf("auth/%s/oidc/poll", mount)
 		for {
 			time.Sleep(time.Duration(interval) * time.Second)
 
-			secret, err := c.Logical().ReadWithData(pollUrl, data)
+			secret, err := c.Logical().Write(pollUrl, data)
 			if err == nil {
 				return secret, nil
 			}

From 4509ac2e2b126ccfeaa0f0d2501ff2eeded67d77 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Fri, 28 Aug 2020 17:49:16 -0500
Subject: [PATCH 14/25] supply client_nonce and use Update instead of Read for
 poll

---
 path_oidc_test.go | 13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/path_oidc_test.go b/path_oidc_test.go
index 52e6fa7..25777ab 100644
--- a/path_oidc_test.go
+++ b/path_oidc_test.go
@@ -226,10 +226,13 @@ func TestOIDC_Callback(t *testing.T) {
 			b, storage, s := getBackendAndServer(t, useBoundCIDRs, callbackMode)
 			defer s.server.Close()
 
+			clientNonce := "456"
+
 			// get auth_url
 			data := map[string]interface{}{
 				"role":         "test",
 				"redirect_uri": "https://example.com",
+				"client_nonce": clientNonce,
 			}
 			req := &logical.Request{
 				Operation: logical.UpdateOperation,
@@ -261,8 +264,9 @@ func TestOIDC_Callback(t *testing.T) {
 				Path:      "oidc/callback",
 				Storage:   storage,
 				Data: map[string]interface{}{
-					"state":       state,
-					"code":        "abc",
+					"state":        state,
+					"code":         "abc",
+					"client_nonce": clientNonce,
 				},
 				Connection: &logical.Connection{
 					RemoteAddr: "127.0.0.42",
@@ -276,11 +280,12 @@ func TestOIDC_Callback(t *testing.T) {
 
 			if callbackMode == "direct" {
 				req = &logical.Request{
-					Operation: logical.ReadOperation,
+					Operation: logical.UpdateOperation,
 					Path:      "oidc/poll",
 					Storage:   storage,
 					Data: map[string]interface{}{
-						"state": state,
+						"state":        state,
+						"client_nonce": clientNonce,
 					},
 				}
 				resp, err = b.HandleRequest(context.Background(), req)

From 8ab48854b655c32157ccc13d1682c9c498c022d0 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Mon, 17 Aug 2020 12:41:43 -0500
Subject: [PATCH 15/25] add OIDCDeviceAuthURL and function to discover it

---
 path_config.go | 89 +++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 88 insertions(+), 1 deletion(-)

diff --git a/path_config.go b/path_config.go
index ef6f71d..5b3d07f 100644
--- a/path_config.go
+++ b/path_config.go
@@ -4,9 +4,12 @@ import (
 	"context"
 	"crypto/tls"
 	"crypto/x509"
+	"encoding/json"
 	"errors"
 	"fmt"
+	"io/ioutil"
 	"net/http"
+	"net/url"
 	"strings"
 
 	"github.com/coreos/go-oidc"
@@ -148,6 +151,87 @@ func (b *jwtAuthBackend) config(ctx context.Context, s logical.Storage) (*jwtCon
 	return config, nil
 }
 
+func contactIssuer(ctx context.Context, uri string, data *url.Values, ignoreBad bool) ([]byte, error) {
+	var req *http.Request
+	var err error
+	if data == nil {
+		req, err = http.NewRequest("GET", uri, nil)
+	} else {
+		req, err = http.NewRequest("POST", uri, strings.NewReader(data.Encode()))
+	}
+	if err != nil {
+		return nil, nil
+	}
+	if data != nil {
+		req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
+	}
+
+	client, ok := ctx.Value(oauth2.HTTPClient).(*http.Client)
+	if !ok {
+		client = http.DefaultClient
+	}
+	resp, err := client.Do(req.WithContext(ctx))
+	if err != nil {
+		return nil, nil
+	}
+	defer resp.Body.Close()
+
+	body, err := ioutil.ReadAll(resp.Body)
+	if err != nil {
+		return nil, nil
+	}
+
+	if resp.StatusCode != http.StatusOK && (!ignoreBad || resp.StatusCode != http.StatusBadRequest) {
+		return nil, fmt.Errorf("%s: %s", resp.Status, body)
+	}
+
+	return body, nil
+}
+
+// Discover the device_authorization_endpoint URL and store it in the config
+// This should be in coreos/go-oidc but they don't yet support device flow
+func (b *jwtAuthBackend) configDeviceAuthURL(ctx context.Context, s logical.Storage) (error) {
+	config, err := b.config(ctx, s)
+	if err != nil {
+		return err
+	}
+
+	b.l.Lock()
+	defer b.l.Unlock()
+
+	if config.OIDCDeviceAuthURL != "" {
+		if config.OIDCDeviceAuthURL == "N/A" {
+			return fmt.Errorf("no device auth endpoint url discovered")
+		}
+		return nil
+	}
+
+	caCtx, err := b.createCAContext(b.providerCtx, config.OIDCDiscoveryCAPEM)
+	if err != nil {
+		return errwrap.Wrapf("error creating context for device auth: {{err}}", err)
+	}
+
+	issuer := config.OIDCDiscoveryURL
+
+	wellKnown := strings.TrimSuffix(issuer, "/") + "/.well-known/openid-configuration"
+	body, err := contactIssuer(caCtx, wellKnown, nil, false)
+	if err != nil {
+		return errwrap.Wrapf("error reading issuer config: {{err}}", err)
+	}
+
+	var daj struct {
+		DeviceAuthURL  string  `json:"device_authorization_endpoint"`
+	}
+	err = json.Unmarshal(body, &daj)
+	if err != nil || daj.DeviceAuthURL == "" {
+		b.cachedConfig.OIDCDeviceAuthURL = "N/A"
+		return fmt.Errorf("no device auth endpoint url discovered")
+	}
+
+	b.cachedConfig.OIDCDeviceAuthURL = daj.DeviceAuthURL
+	return nil
+}
+
 func (b *jwtAuthBackend) pathConfigRead(ctx context.Context, req *logical.Request, d *framework.FieldData) (*logical.Response, error) {
 	config, err := b.config(ctx, req.Storage)
 	if err != nil {
@@ -355,7 +439,10 @@ type jwtConfig struct {
 	DefaultRole          string                 `json:"default_role"`
 	ProviderConfig       map[string]interface{} `json:"provider_config"`
 
-	ParsedJWTPubKeys []interface{} `json:"-"`
+	// these are calculated from JWTValidationPubKeys when needed
+	ParsedJWTPubKeys     []interface{}           `json:"-"`
+	// this is looked up from OIDCDiscoveryURL when needed
+	OIDCDeviceAuthURL    string                  `json:"-"`
 }
 
 const (

From 9c33f716b2d50104dbf8db80e33e1e85bd4a3059 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Mon, 17 Aug 2020 12:42:31 -0500
Subject: [PATCH 16/25] add device callback mode and poll_interval option

---
 path_role.go | 26 ++++++++++++++++++++++++--
 1 file changed, 24 insertions(+), 2 deletions(-)

diff --git a/path_role.go b/path_role.go
index 1c19794..4f045fd 100644
--- a/path_role.go
+++ b/path_role.go
@@ -24,6 +24,7 @@ const (
 	boundClaimsTypeGlob   = "glob"
 	callbackModeDirect    = "direct"
 	callbackModeClient    = "client"
+	callbackModeDevice    = "device"
 )
 
 func pathRoleList(b *jwtAuthBackend) *framework.Path {
@@ -142,9 +143,14 @@ Defaults to 60 (1 minute) if set to 0 and can be disabled if set to -1.`,
 			},
 			"callback_mode": {
 				Type:        framework.TypeString,
-				Description: `OIDC callback mode from Authorization Server: allowed values are 'direct' to Vault or 'client', default 'client'`,
+				Description: `OIDC callback mode from Authorization Server: allowed values are 'device' for device flow, 'direct' to Vault, or 'client', default 'client'`,
 				Default:     callbackModeClient,
 			},
+			"poll_interval": {
+				Type:        framework.TypeInt,
+				Description: `poll interval in seconds for device and direct flows, default '5'`,
+				// don't set Default here because server may also set a default
+			},
 			"verbose_oidc_logging": {
 				Type: framework.TypeBool,
 				Description: `Log received OIDC tokens and claims when debug-level logging is active. 
@@ -209,6 +215,7 @@ type jwtRole struct {
 	OIDCScopes          []string               `json:"oidc_scopes"`
 	AllowedRedirectURIs []string               `json:"allowed_redirect_uris"`
 	CallbackMode        string                 `json:"callback_mode"`
+	PollInterval        int                    `json:"poll_interval"`
 	VerboseOIDCLogging  bool                   `json:"verbose_oidc_logging"`
 
 	// Deprecated by TokenParams
@@ -321,6 +328,10 @@ func (b *jwtAuthBackend) pathRoleRead(ctx context.Context, req *logical.Request,
 
 	role.PopulateTokenData(d)
 
+	if role.PollInterval > 0 {
+		d["poll_interval"] = role.PollInterval
+	}
+
 	if len(role.Policies) > 0 {
 		d["policies"] = d["token_policies"]
 	}
@@ -517,14 +528,25 @@ func (b *jwtAuthBackend) pathRoleCreateUpdate(ctx context.Context, req *logical.
 		role.AllowedRedirectURIs = allowedRedirectURIs.([]string)
 	}
 
+	if pollInterval, ok := data.GetOk("poll_interval"); ok {
+		role.PollInterval = pollInterval.(int)
+	}
+
 	callbackMode := data.Get("callback_mode").(string)
 	switch callbackMode {
-	case callbackModeDirect, callbackModeClient:
+	case callbackModeDevice, callbackModeDirect, callbackModeClient:
 		role.CallbackMode = callbackMode
 	default:
 		return logical.ErrorResponse("invalid 'callback_mode': %s", callbackMode), nil
 	}
 
+	if callbackMode == callbackModeDevice {
+		err = b.configDeviceAuthURL(ctx, req.Storage)
+		if err != nil {
+			return nil, err
+		}
+	}
+
 	if role.RoleType == "oidc" && len(role.AllowedRedirectURIs) == 0 {
 		return logical.ErrorResponse(
 			"'allowed_redirect_uris' must be set if 'role_type' is 'oidc' or unspecified."), nil

From b4c05094737e424d82accfdf857e662fa122f256 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Mon, 17 Aug 2020 12:43:36 -0500
Subject: [PATCH 17/25] add device flow callback mode

---
 path_oidc.go | 226 ++++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 186 insertions(+), 40 deletions(-)

diff --git a/path_oidc.go b/path_oidc.go
index 3f7cc56..be3b95c 100644
--- a/path_oidc.go
+++ b/path_oidc.go
@@ -32,14 +32,14 @@ const (
 	noCode = "no_code"
 )
 
-// oidcState is created when an authURL is requested. The state identifier is
-// passed throughout the OAuth process.
+// oidcState is created when an authURL is requested while not using the
+//  device flow. The state identifier is passed throughout the OAuth process.
 type oidcState struct {
-	rolename    string
-	nonce       string
-	redirectURI string
-	code        string
-	idToken     string
+	rolename       string
+	nonce          string
+	redirectOrCode string
+	code           string
+	idToken        string
 
 	// clientNonce is used between Vault and the client/application (e.g. CLI) making the request,
 	// and is unrelated to the OIDC nonce above. It is optional.
@@ -117,7 +117,7 @@ func pathOIDC(b *jwtAuthBackend) []*framework.Path {
 				},
 				"redirect_uri": {
 					Type:        framework.TypeString,
-					Description: "The OAuth redirect_uri to use in the authorization URL.",
+					Description: "The OAuth redirect_uri to use in the authorization URL.  Not needed with device flow.",
 				},
 				"client_nonce": {
 					Type:        framework.TypeString,
@@ -170,7 +170,7 @@ func (b *jwtAuthBackend) pathCallbackPost(ctx context.Context, req *logical.Requ
 		state.code = code
 		state.idToken = idToken
 		b.setState(stateID, state)
-		mount := parseMount(state.redirectURI)
+		mount := parseMount(state.redirectOrCode)
 		if mount == "" {
 			resp.Data[logical.HTTPRawBody] = []byte(errorHTML(errLoginFailed, "Invalid redirect path."))
 			resp.Data[logical.HTTPStatusCode] = http.StatusBadRequest
@@ -211,24 +211,27 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 		return logical.ErrorResponse(errLoginFailed + " Expired or missing OAuth state."), nil
 	}
 
+	deleteState := true
+	defer func() {
+		if deleteState {
+			b.deleteState(stateID)
+		}
+	}()
+
 	roleName := state.rolename
 	role, err := b.role(ctx, req.Storage, roleName)
 	if err != nil {
-		b.deleteState(stateID)
 		return nil, err
 	}
 	if role == nil {
-		b.deleteState(stateID)
 		return logical.ErrorResponse(errLoginFailed + " Role could not be found"), nil
 	}
 
 	useHttp := false
 	if role.CallbackMode == callbackModeDirect {
 		useHttp = true
-	}
-	if !useHttp {
-		// state is only accessed once when not using direct callback
-		b.deleteState(stateID)
+		// save state for poll
+		deleteState = false
 	}
 
 	errorDescription := d.Get("error_description").(string)
@@ -268,7 +271,7 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 	var oauth2Config = oauth2.Config{
 		ClientID:     config.OIDCClientID,
 		ClientSecret: config.OIDCClientSecret,
-		RedirectURL:  state.redirectURI,
+		RedirectURL:  state.redirectOrCode,
 		Endpoint:     provider.Endpoint(),
 		Scopes:       []string{oidc.ScopeOpenID},
 	}
@@ -300,6 +303,14 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 		}
 	}
 
+	return b.processToken(ctx, config, oidcCtx, provider, roleName, role, rawToken, oauth2Token, stateID, state, useHttp)
+}
+
+
+// Continue processing a token after it has been received from the
+//  OIDC provider from either code or device authorization flows
+func (b *jwtAuthBackend) processToken(ctx context.Context, config *jwtConfig, oidcCtx context.Context, provider *oidc.Provider, roleName string, role *jwtRole, rawToken string, oauth2Token *oauth2.Token, stateID string, state *oidcState, useHttp bool) (*logical.Response, error) {
+
 	if role.VerboseOIDCLogging {
 		b.Logger().Debug("OIDC provider response", "ID token", rawToken)
 	}
@@ -310,10 +321,12 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 		return loginFailedResponse(useHttp, fmt.Sprintf("%s %s", errTokenVerification, err.Error())), nil
 	}
 
-	if allClaims["nonce"] != state.nonce {
-		return loginFailedResponse(useHttp, "Invalid ID token nonce."), nil
+	if claimNonce, ok := allClaims["nonce"]; ok {
+		if state != nil && claimNonce != state.nonce {
+			return loginFailedResponse(useHttp, "invalid ID token nonce."), nil
+		}
+		delete(allClaims, "nonce")
 	}
-	delete(allClaims, "nonce")
 
 	// If we have a token, attempt to fetch information from the /userinfo endpoint
 	// and merge it with the existing claims data. A failure to fetch additional information
@@ -389,27 +402,108 @@ func (b *jwtAuthBackend) pathCallback(ctx context.Context, req *logical.Request,
 	return resp, nil
 }
 
+
+// second half of the client API for direct and device callback modes
 func (b *jwtAuthBackend) pathPoll(ctx context.Context, req *logical.Request, d *framework.FieldData) (*logical.Response, error) {
-	stateID := d.Get("state").(string)
+	config, err := b.config(ctx, req.Storage)
+	if err != nil {
+		return nil, err
+	}
+	if config == nil {
+		return logical.ErrorResponse(errLoginFailed + " Could not load configuration"), nil
+	}
 
+	stateID := d.Get("state").(string)
 	state := b.getState(stateID)
 	if state == nil {
 		return logical.ErrorResponse(errLoginFailed + " Expired or missing OAuth state."), nil
 	}
 
+	deleteState := true
+	defer func() {
+		if deleteState {
+			b.deleteState(stateID)
+		}
+	}()
+
 	clientNonce := d.Get("client_nonce").(string)
 
 	if state.clientNonce != "" && clientNonce != state.clientNonce {
-		b.deleteState(stateID)
 		return logical.ErrorResponse("invalid client_nonce"), nil
 	}
 
+	roleName := state.rolename
+	role, err := b.role(ctx, req.Storage, roleName)
+	if err != nil {
+		return nil, err
+	}
+	if role == nil {
+		return logical.ErrorResponse(errLoginFailed + " Role could not be found"), nil
+	}
+
+	if role.CallbackMode == callbackModeDevice {
+		caCtx, err := b.createCAContext(ctx, config.OIDCDiscoveryCAPEM)
+		if err != nil {
+			return nil, err
+		}
+		provider, err := b.getProvider(config)
+		if err != nil {
+			return nil, errwrap.Wrapf("error getting provider for poll operation: {{err}}", err)
+		}
+
+		values := url.Values {
+			"client_id": {config.OIDCClientID},
+			"client_secret": {config.OIDCClientSecret},
+			"device_code": {state.redirectOrCode},
+			"grant_type": {"urn:ietf:params:oauth:grant-type:device_code"},
+		}
+		body, err := contactIssuer(caCtx, provider.Endpoint().TokenURL, &values, true)
+		if err != nil {
+			return nil, errwrap.Wrapf("error polling for device authorization: {{err}}", err)
+		}
+
+		var tokenOrError struct {
+			*oauth2.Token
+			Error string `json:"error,omitempty"`
+		}
+		err = json.Unmarshal(body, &tokenOrError)
+		if err != nil {
+			return nil, fmt.Errorf("error decoding issuer response while polling for token: %v", err)
+		}
+
+		if tokenOrError.Error != "" {
+			if tokenOrError.Error == "authorization_pending" || tokenOrError.Error == "slow_down" {
+				// save state for another poll
+				deleteState = false
+				return logical.ErrorResponse(tokenOrError.Error), nil
+			}
+			return logical.ErrorResponse("authorization failed: %v", tokenOrError.Error), nil
+		}
+
+		extra := make(map[string]interface{})
+		err = json.Unmarshal(body, &extra)
+		if err != nil {
+			// already been unmarshalled once, unlikely
+			return nil, err
+		}
+		oauth2Token := tokenOrError.Token.WithExtra(extra)
+
+		rawToken, ok := oauth2Token.Extra("id_token").(string)
+		if !ok {
+			return logical.ErrorResponse(errTokenVerification + " No id_token found in response."), nil
+		}
+
+		return b.processToken(ctx, config, caCtx, provider, roleName, role, rawToken, oauth2Token, "", nil, false)
+	}
+
+	// else it's the direct callback mode
 	if state.auth == nil {
+		// save state for another poll
+		deleteState = false
 		// Return the same response as oauth 2.0 device flow in RFC8628
 		return logical.ErrorResponse("authorization_pending"), nil
 	}
 
-	b.deleteState(stateID)
 	resp := &logical.Response{
 		Auth: state.auth,
 	}
@@ -451,9 +545,6 @@ func (b *jwtAuthBackend) authURL(ctx context.Context, req *logical.Request, d *f
 	}
 
 	redirectURI := d.Get("redirect_uri").(string)
-	if redirectURI == "" {
-		return logical.ErrorResponse("missing redirect_uri"), nil
-	}
 
 	role, err := b.role(ctx, req.Storage, roleName)
 	if err != nil {
@@ -466,6 +557,66 @@ func (b *jwtAuthBackend) authURL(ctx context.Context, req *logical.Request, d *f
 	clientNonce := d.Get("client_nonce").(string)
 	if clientNonce == "" && role.CallbackMode != callbackModeClient {
 		return logical.ErrorResponse("missing client_nonce"), nil
+
+	// "openid" is a required scope for OpenID Connect flows
+	scopes := append([]string{oidc.ScopeOpenID}, role.OIDCScopes...)
+
+	if role.CallbackMode == callbackModeDevice {
+		// start a device flow
+		caCtx, err := b.createCAContext(ctx, config.OIDCDiscoveryCAPEM)
+		if err != nil {
+			return nil, err
+		}
+		values := url.Values {
+			"client_id": {config.OIDCClientID},
+			"scope":     {strings.Join(scopes, " ")},
+		}
+		body, err := contactIssuer(caCtx, config.OIDCDeviceAuthURL, &values, false)
+		if err != nil {
+			return nil, errwrap.Wrapf("error authorizing device: {{err}}", err)
+		}
+		var deviceCode struct {
+			DeviceCode              string `json:"device_code"`
+			UserCode                string `json:"user_code"`
+			VerificationURI         string `json:"verification_uri"`
+			VerificationURIComplete string `json:"verification_uri_complete"`
+			Interval                int    `json:"interval"`
+		}
+		err = json.Unmarshal(body, &deviceCode)
+		if err != nil {
+			return nil, errwrap.Wrapf("error decoding issuer response to device auth: {{err}}", err)
+		}
+		stateID, _, err := b.createState(roleName, deviceCode.DeviceCode, clientNonce)
+		if err != nil {
+			logger.Warn("error generating OAuth state", "error", err)
+			return resp, nil
+		}
+
+		if deviceCode.VerificationURIComplete != "" {
+			resp.Data["auth_url"] = deviceCode.VerificationURIComplete
+		} else {
+			resp.Data["auth_url"] = deviceCode.VerificationURI
+			resp.Data["user_code"] = deviceCode.UserCode
+		}
+		resp.Data["state"] = stateID
+		interval := 5
+		if role.PollInterval != 0 {
+			interval = role.PollInterval
+		} else if deviceCode.Interval != 0 {
+			interval = deviceCode.Interval
+		}
+		resp.Data["poll_interval"] = fmt.Sprintf("%d", interval)
+		return resp, nil
+	}
+
+	if redirectURI == "" {
+		return logical.ErrorResponse("missing redirect_uri"), nil
+	}
+
+	stateID, nonce, err := b.createState(roleName, redirectURI, clientNonce)
+	if err != nil {
+		logger.Warn("error generating OAuth state", "error", err)
+		return resp, nil
 	}
 
 	if !validRedirect(redirectURI, role.AllowedRedirectURIs) {
@@ -488,9 +639,6 @@ func (b *jwtAuthBackend) authURL(ctx context.Context, req *logical.Request, d *f
 		return resp, nil
 	}
 
-	// "openid" is a required scope for OpenID Connect flows
-	scopes := append([]string{oidc.ScopeOpenID}, role.OIDCScopes...)
-
 	// Configure an OpenID Connect aware OAuth2 client
 	oauth2Config := oauth2.Config{
 		ClientID:     config.OIDCClientID,
@@ -500,12 +648,6 @@ func (b *jwtAuthBackend) authURL(ctx context.Context, req *logical.Request, d *f
 		Scopes:       scopes,
 	}
 
-	stateID, nonce, err := b.createState(roleName, redirectURI, clientNonce)
-	if err != nil {
-		logger.Warn("error generating OAuth state", "error", err)
-		return resp, nil
-	}
-
 	authCodeOpts := []oauth2.AuthCodeOption{
 		oidc.Nonce(nonce),
 	}
@@ -535,7 +677,11 @@ func (b *jwtAuthBackend) authURL(ctx context.Context, req *logical.Request, d *f
 	resp.Data["auth_url"] = urlStr
 	if role.CallbackMode == callbackModeDirect {
 		resp.Data["state"] = stateID
-		resp.Data["poll_interval"] = "5"
+		interval := 5
+		if role.PollInterval != 0 {
+			interval = role.PollInterval
+		}
+		resp.Data["poll_interval"] = fmt.Sprintf("%d", interval)
 	}
 
 	return resp, nil
@@ -544,7 +690,7 @@ func (b *jwtAuthBackend) authURL(ctx context.Context, req *logical.Request, d *f
 // createState make an expiring state object, associated with a random state ID
 // that is passed throughout the OAuth process. A nonce is also included in the
 // auth process, and for simplicity will be identical in length/format as the state ID.
-func (b *jwtAuthBackend) createState(rolename, redirectURI, clientNonce string) (string, string, error) {
+func (b *jwtAuthBackend) createState(rolename, redirectOrCode, clientNonce string) (string, string, error) {
 	// Get enough bytes for 2 160-bit IDs (per rfc6749#section-10.10)
 	bytes, err := uuid.GenerateRandomBytes(2 * 20)
 	if err != nil {
@@ -555,10 +701,10 @@ func (b *jwtAuthBackend) createState(rolename, redirectURI, clientNonce string)
 	nonce := fmt.Sprintf("%x", bytes[20:])
 
 	b.oidcStates.SetDefault(stateID, &oidcState{
-		rolename:    rolename,
-		nonce:       nonce,
-		redirectURI: redirectURI,
-		clientNonce: clientNonce,
+		rolename:       rolename,
+		nonce:          nonce,
+		redirectOrCode: redirectOrCode,
+		clientNonce:    clientNonce,
 	})
 
 	return stateID, nonce, nil

From 8c1903454e2ffd92d515a07c8dffe26602adb697 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Mon, 17 Aug 2020 12:45:51 -0500
Subject: [PATCH 18/25] add device callbackmode, report auth user_code if
 present, and handle slow_down poll response

---
 cli.go | 22 +++++++++++++++-------
 1 file changed, 15 insertions(+), 7 deletions(-)

diff --git a/cli.go b/cli.go
index c7bab2c..5723676 100644
--- a/cli.go
+++ b/cli.go
@@ -108,18 +108,20 @@ func (h *CLIHandler) Auth(c *api.Client, m map[string]string) (*api.Secret, erro
 	var pollInterval string
 	var interval int
 	var state string
+	var userCode string
 	var listener net.Listener
 
 	if secret != nil {
 		pollInterval, _ = secret.Data["poll_interval"].(string)
 		state, _ = secret.Data["state"].(string)
+		userCode, _ = secret.Data["user_code"].(string)
 	}
-	if callbackMode == "direct" {
+	if callbackMode != "client" {
 		if state == "" {
-			return nil, errors.New("no state returned in direct callback mode")
+			return nil, errors.New("no state returned in " + callbackMode + " callback mode")
 		}
 		if pollInterval == "" {
-			return nil, errors.New("no poll_interval returned in direct callback mode")
+			return nil, errors.New("no poll_interval returned in " + callbackMode + " callback mode")
 		}
 		interval, err = strconv.Atoi(pollInterval)
 		if err != nil {
@@ -147,8 +149,11 @@ func (h *CLIHandler) Auth(c *api.Client, m map[string]string) (*api.Secret, erro
 	if err := openURL(authURL); err != nil {
 		fmt.Fprintf(os.Stderr, "Error attempting to automatically open browser: '%s'.\nPlease visit the authorization URL manually.", err)
 	}
+	if userCode != "" {
+		fmt.Fprintf(os.Stderr, "When prompted, enter code %s\n\n", userCode)
+	}
 
-	if callbackMode == "direct" {
+	if callbackMode != "client" {
 		data := map[string]interface{}{
 			"state":        state,
 			"client_nonce": clientNonce,
@@ -161,7 +166,9 @@ func (h *CLIHandler) Auth(c *api.Client, m map[string]string) (*api.Secret, erro
 			if err == nil {
 				return secret, nil
 			}
-			if !strings.HasSuffix(err.Error(), "authorization_pending") {
+			if strings.HasSuffix(err.Error(), "slow_down") {
+				interval *= 2
+			} else if !strings.HasSuffix(err.Error(), "authorization_pending") {
 				return nil, err
 			}
 			// authorization is pending, try again
@@ -357,8 +364,9 @@ Configuration:
     Vault role of type "OIDC" to use for authentication.
 
   callbackmode=<string>
-    Mode of callback: "direct" for direct connection to Vault or "client"
-    for connection to command line client (default: client).
+    Mode of callback: "direct" for direct connection to Vault, "client"
+    for connection to command line client, or "device" for device flow
+    which has no callback (default: client).
 
   listenaddress=<string>
     Optional address to bind the OIDC callback listener to in client callback

From a5c21e6a22220bade7965286937d687c8a66def4 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Mon, 17 Aug 2020 12:59:55 -0500
Subject: [PATCH 19/25] update description of poll_interval

---
 path_role.go | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/path_role.go b/path_role.go
index 4f045fd..93e2274 100644
--- a/path_role.go
+++ b/path_role.go
@@ -148,8 +148,8 @@ Defaults to 60 (1 minute) if set to 0 and can be disabled if set to -1.`,
 			},
 			"poll_interval": {
 				Type:        framework.TypeInt,
-				Description: `poll interval in seconds for device and direct flows, default '5'`,
-				// don't set Default here because server may also set a default
+				Description: `poll interval in seconds for device and direct flows, default value from Authorization Server for device flow, or '5'`,
+				// don't set Default here because server may set a default
 			},
 			"verbose_oidc_logging": {
 				Type: framework.TypeBool,

From 4c8e6a331e4f034c3e80b19768aefac685c73303 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Wed, 19 Aug 2020 08:51:43 -0500
Subject: [PATCH 20/25] revert comment on oidcState

---
 path_oidc.go | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/path_oidc.go b/path_oidc.go
index be3b95c..97cd643 100644
--- a/path_oidc.go
+++ b/path_oidc.go
@@ -32,8 +32,8 @@ const (
 	noCode = "no_code"
 )
 
-// oidcState is created when an authURL is requested while not using the
-//  device flow. The state identifier is passed throughout the OAuth process.
+// oidcState is created when an authURL is requested. The state identifier is
+// passed throughout the OAuth process.
 type oidcState struct {
 	rolename       string
 	nonce          string

From 9161b88f3d943305871ae6647ea8cf5a23c8b251 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Wed, 19 Aug 2020 09:08:15 -0500
Subject: [PATCH 21/25] only load config in pathPoll when in device flow

---
 path_oidc.go | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/path_oidc.go b/path_oidc.go
index 97cd643..d17951d 100644
--- a/path_oidc.go
+++ b/path_oidc.go
@@ -405,14 +405,6 @@ func (b *jwtAuthBackend) processToken(ctx context.Context, config *jwtConfig, oi
 
 // second half of the client API for direct and device callback modes
 func (b *jwtAuthBackend) pathPoll(ctx context.Context, req *logical.Request, d *framework.FieldData) (*logical.Response, error) {
-	config, err := b.config(ctx, req.Storage)
-	if err != nil {
-		return nil, err
-	}
-	if config == nil {
-		return logical.ErrorResponse(errLoginFailed + " Could not load configuration"), nil
-	}
-
 	stateID := d.Get("state").(string)
 	state := b.getState(stateID)
 	if state == nil {
@@ -442,6 +434,14 @@ func (b *jwtAuthBackend) pathPoll(ctx context.Context, req *logical.Request, d *
 	}
 
 	if role.CallbackMode == callbackModeDevice {
+		config, err := b.config(ctx, req.Storage)
+		if err != nil {
+			return nil, err
+		}
+		if config == nil {
+			return logical.ErrorResponse(errLoginFailed + " Could not load configuration"), nil
+		}
+
 		caCtx, err := b.createCAContext(ctx, config.OIDCDiscoveryCAPEM)
 		if err != nil {
 			return nil, err

From afa6a056ecc79cc27b81a50882722196ee3823ff Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Fri, 28 Aug 2020 11:59:47 -0500
Subject: [PATCH 22/25] add separate message if poll response is not json

---
 path_oidc.go | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/path_oidc.go b/path_oidc.go
index d17951d..6ba6639 100644
--- a/path_oidc.go
+++ b/path_oidc.go
@@ -462,6 +462,10 @@ func (b *jwtAuthBackend) pathPoll(ctx context.Context, req *logical.Request, d *
 			return nil, errwrap.Wrapf("error polling for device authorization: {{err}}", err)
 		}
 
+		if body[0] != '{' {
+			return nil, fmt.Errorf("issuer response while polling for token is not json: %v", string(body))
+		}
+
 		var tokenOrError struct {
 			*oauth2.Token
 			Error string `json:"error,omitempty"`

From 26775229f8752a89ce6ec8d0b7cb0061d0907805 Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Fri, 28 Aug 2020 18:07:27 -0500
Subject: [PATCH 23/25] correct rebase merge error

---
 path_oidc.go | 1 +
 1 file changed, 1 insertion(+)

diff --git a/path_oidc.go b/path_oidc.go
index 6ba6639..0159b59 100644
--- a/path_oidc.go
+++ b/path_oidc.go
@@ -561,6 +561,7 @@ func (b *jwtAuthBackend) authURL(ctx context.Context, req *logical.Request, d *f
 	clientNonce := d.Get("client_nonce").(string)
 	if clientNonce == "" && role.CallbackMode != callbackModeClient {
 		return logical.ErrorResponse("missing client_nonce"), nil
+	}
 
 	// "openid" is a required scope for OpenID Connect flows
 	scopes := append([]string{oidc.ScopeOpenID}, role.OIDCScopes...)

From 85de580733c3d9c1d77eace8e6634976cc7bafbe Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Tue, 1 Sep 2020 17:17:46 -0500
Subject: [PATCH 24/25] do not assume json has to start with open bracket

---
 path_oidc.go | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/path_oidc.go b/path_oidc.go
index 0159b59..454eb9b 100644
--- a/path_oidc.go
+++ b/path_oidc.go
@@ -462,17 +462,13 @@ func (b *jwtAuthBackend) pathPoll(ctx context.Context, req *logical.Request, d *
 			return nil, errwrap.Wrapf("error polling for device authorization: {{err}}", err)
 		}
 
-		if body[0] != '{' {
-			return nil, fmt.Errorf("issuer response while polling for token is not json: %v", string(body))
-		}
-
 		var tokenOrError struct {
 			*oauth2.Token
 			Error string `json:"error,omitempty"`
 		}
 		err = json.Unmarshal(body, &tokenOrError)
 		if err != nil {
-			return nil, fmt.Errorf("error decoding issuer response while polling for token: %v", err)
+			return nil, fmt.Errorf("error decoding issuer response while polling for token: %v; response: %v", err, string(body))
 		}
 
 		if tokenOrError.Error != "" {

From e8670da3bad5adf97885e5abe08fccf65eb1a47f Mon Sep 17 00:00:00 2001
From: Dave Dykstra <2129743+DrDaveD@users.noreply.github.com>
Date: Tue, 1 Sep 2020 17:19:46 -0500
Subject: [PATCH 25/25] add device flow test

---
 path_oidc_test.go | 83 ++++++++++++++++++++++++++++++-----------------
 1 file changed, 54 insertions(+), 29 deletions(-)

diff --git a/path_oidc_test.go b/path_oidc_test.go
index 25777ab..b66ccc3 100644
--- a/path_oidc_test.go
+++ b/path_oidc_test.go
@@ -213,14 +213,16 @@ func TestOIDC_Callback(t *testing.T) {
 
 		// run test with and without bound_cidrs configured
 		//   and with and without direct callback mode
-		for i := 1; i <= 3; i++ {
+		for i := 1; i <= 4; i++ {
 			var useBoundCIDRs bool
-			var callbackMode string
+			callbackMode := "client"
 
 			if i == 2 {
 				useBoundCIDRs = true
 			} else if i == 3 {
 				callbackMode = "direct"
+			} else if i == 4 {
+				callbackMode = "device"
 			}
 
 			b, storage, s := getBackendAndServer(t, useBoundCIDRs, callbackMode)
@@ -228,6 +230,9 @@ func TestOIDC_Callback(t *testing.T) {
 
 			clientNonce := "456"
 
+			// set mock provider's expected code
+			s.code = "abc"
+
 			// get auth_url
 			data := map[string]interface{}{
 				"role":         "test",
@@ -246,39 +251,43 @@ func TestOIDC_Callback(t *testing.T) {
 				t.Fatalf("err:%v resp:%#v\n", err, resp)
 			}
 
-			authURL := resp.Data["auth_url"].(string)
+			var state string
 
-			state := getQueryParam(t, authURL, "state")
-			nonce := getQueryParam(t, authURL, "nonce")
+			if callbackMode == "device" {
+				state = resp.Data["state"].(string)
+				s.customClaims =  sampleClaims("")
+			} else {
+				authURL := resp.Data["auth_url"].(string)
+				state = getQueryParam(t, authURL, "state")
+				nonce := getQueryParam(t, authURL, "nonce")
 
-			// set provider claims that will be returned by the mock server
-			s.customClaims = sampleClaims(nonce)
+				// set provider claims that will be returned by the mock server
+				s.customClaims = sampleClaims(nonce)
 
-			// set mock provider's expected code
-			s.code = "abc"
+				// invoke the callback, which will in to try to exchange the code
+				// with the mock provider.
+				req = &logical.Request{
+					Operation: logical.ReadOperation,
+					Path:      "oidc/callback",
+					Storage:   storage,
+					Data: map[string]interface{}{
+						"state":        state,
+						"code":         "abc",
+						"client_nonce": clientNonce,
+					},
+					Connection: &logical.Connection{
+						RemoteAddr: "127.0.0.42",
+					},
+				}
 
-			// invoke the callback, which will in to try to exchange the code
-			// with the mock provider.
-			req = &logical.Request{
-				Operation: logical.ReadOperation,
-				Path:      "oidc/callback",
-				Storage:   storage,
-				Data: map[string]interface{}{
-					"state":        state,
-					"code":         "abc",
-					"client_nonce": clientNonce,
-				},
-				Connection: &logical.Connection{
-					RemoteAddr: "127.0.0.42",
-				},
+				resp, err = b.HandleRequest(context.Background(), req)
+				if err != nil {
+					t.Fatal(err)
+				}
 			}
 
-			resp, err = b.HandleRequest(context.Background(), req)
-			if err != nil {
-				t.Fatal(err)
-			}
 
-			if callbackMode == "direct" {
+			if callbackMode != "client" {
 				req = &logical.Request{
 					Operation: logical.UpdateOperation,
 					Path:      "oidc/poll",
@@ -834,6 +843,7 @@ func (o *oidcProvider) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 			{
 				"issuer": "%s",
 				"authorization_endpoint": "%s/auth",
+				"device_authorization_endpoint": "%s/device",
 				"token_endpoint": "%s/token",
 				"jwks_uri": "%s/certs",
 				"userinfo_endpoint": "%s/userinfo"
@@ -845,8 +855,23 @@ func (o *oidcProvider) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 		w.WriteHeader(404)
 	case "/certs_invalid":
 		w.Write([]byte("It's not a keyset!"))
+	case "/device":
+		values := map[string]interface{} {
+			"device_code": o.code,
+		}
+		data, err := json.Marshal(values)
+		if err != nil {
+			o.t.Fatal(err)
+		}
+		w.Write(data)
 	case "/token":
-		code := r.FormValue("code")
+		var code string
+		grant_type := r.FormValue("grant_type")
+		if grant_type == "urn:ietf:params:oauth:grant-type:device_code" {
+			code = r.FormValue("device_code")
+		} else {
+			code = r.FormValue("code")
+		}
 
 		if code != o.code {
 			w.WriteHeader(401)
